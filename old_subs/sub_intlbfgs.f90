
SUBROUTINE INTLBFGS(QSTART,QFINISH)
USE PORFUNCS
USE KEY, ONLY : FREEZENODEST, FREEZETOL, MAXINTBFGS, CONVR, ATOMSTORES, &
     & INTRMSTOL, INTIMAGE, NREPMAX, NREPULSIVE, INTMUPDATE, INTDGUESS, &
     & NCONSTRAINT, CONI, CONJ, CONDISTREF, INTCONMAX, CONOFFLIST, CONOFFTRIED,  &
     & INTCONSTRAINREPCUT, REPCON, INTCONSTRAINTREP, INTREPSEP, NREPI, NREPJ, &
     & CONDISTREFLOCAL, INTCONFRAC, CONACTIVE, REPI, LPERMOFF, ORBITTOL, &
     & REPJ, NREPMAX, ATOMACTIVE, NCONSTRAINTON, CONION, CONJON, CONDISTREFLOCALON, CONDISTREFON, &
     & NREPCUT, REPCUT, CHECKCONINT, INTCONSTEPS, INTRELSTEPS, MAXCONE, COLDFUSIONLIMIT, &
     & INTSTEPS1, DUMPINTXYZ, DUMPINTXYZFREQ, DUMPINTEOS, DUMPINTEOSFREQ, &
     & IMSEPMIN, IMSEPMAX, MAXINTIMAGE, INTFREEZET, INTFREEZETOL, RIGIDBODY, &
     & INTFROZEN, CHECKREPINTERVAL, NNREPULSIVE, INTFREEZEMIN, INTIMAGECHECK, &
     & CONCUT, CONCUTLOCAL, KINT, BULKT, TWOD, LOCALPERMNEIGH, LOCALPERMCUT2, &
     & QCIADDREP, QCIXYZ, WHOLEDNEB, QCIIMAGE, FROZEN, QCIRESTART, NPERMGROUP, NPERMSIZE, PERMGROUP, NSETS, SETS, &
     & PERMDIST, LOCALPERMCUT, QCILPERMDIST, QCIPDINT, QCIPERMCUT, QCIAMBERT, DOBACK, &
     & QCIRESET, QCIRESETINT1, NCONOFF, EREP, ECON, ESPRING, CONVERGECONTEST, CONVERGEREPTEST, &
     & FCONTEST, FREPTEST, QCIKADJUSTTOL, QCIKADJUSTFRAC, QCIKADJUSTFRQ, QCIKINTMAX, QCIKINTMIN, QCIAVDEV, QCISTOP, QCILPDCON, &
     & NCONCOMMON, COMMONCON, PBETTER, NOPDISTANCE, PDISTANCE, CONCUTABS2, CONCUTABS, QCIPERMT, INTCONSTRAINTDEL, &
     & NPERMGROUPQCI, NPERMGROUPBACK, NSETSQCI, NSETSBACK, SETSQCI, SETSBACK, NPERMSIZEQCI, PERMGROUPQCI, NPERMSIZEBACK, &
     & PERMGROUPBACK, QCISBT, QCIALIGN, QCIALIGNN, QCIALIGNATOMS, QCILINEARLIST, QCILINEARN, QCILINEARATOMS, &
     & QCINMDT, QCINMDN, QCIREADGUESS, QCIGUESSFILE, INTIMAGENEW, QCIIMAGEDENST, IMDENSITY, BOXDERIVT, USEFRACT

USE BOX_DERIVATIVES, ONLY : RESTOREMINIMAGE
USE COMMONS, ONLY: NATOMS, DEBUG, ZSYM, PARAM1, PARAM2, PARAM3
USE MODCHARMM, ONLY : CHRMMT
USE CHIRALITY

IMPLICIT NONE 

DOUBLE PRECISION,INTENT(INOUT) :: QSTART(3*NATOMS), QFINISH(3*NATOMS)  ! The two end points
INTEGER D, U
DOUBLE PRECISION DIST2, SUMEEE, SUMEEE2, SIGMAEEE, NEIGHBOUR_COORDS(12), CENTRE_COORDS(3)!, DIST
DOUBLE PRECISION DMAX, DF, DMIN, ADMAX, CONCUTABSSAVE, MAXCONESAVE, INTRMSTOLSAVE
DOUBLE PRECISION CONCUTABSSAVE2, DUMMYDOBACK
INTEGER NDECREASE, NFAIL, NMAXINT, NMININT, JMAX, JMIN, INTIMAGESAVE, NOFF, J1, J2, JA1, JA2!, NMOVE, NMOVES, NMOVEF
INTEGER NPSTART, PERMP(NATOMS), NBESTDOBACK, NCONCUTABSINC  !, PERM(NATOMS), PERMS(NATOMS), PERMF(NATOMS)
LOGICAL KNOWE, KNOWG, KNOWH, ADDATOM, ADDREP(NATOMS), REMOVEIMAGE!, TURNOFF, IDENTITY
INTEGER, ALLOCATABLE :: STARTGROUP(:), ENDGROUP(:)
LOGICAL CCABSPHASE2, CONCUTABSINC!, PBS, PBF
COMMON /KNOWN/ KNOWE, KNOWG, KNOWH

DOUBLE PRECISION DUMMY, DUMMY2, ADUMMY, KINTSAVE
DOUBLE PRECISION BOXLX,BOXLY,BOXLZ,RMATBEST(3,3),DISTANCEP!,DISTANCE,DISTANCEF,DISTANCES
INTEGER POINT,NPT,J3,J4,NIMAGEFREEZE,NACTIVE,NBEST,NEWATOM,J5,J6,NBEST2,NMOVEP
INTEGER TURNONORDER(NATOMS),NBACKTRACK,NQCIFREEZE
INTEGER NDUMMY, NLASTGOODE, NSTEPSMAX, ACID!, NLASTCHANGE
LOGICAL CHIRALSR, CHIRALSRP 
INTEGER NTRIES(NATOMS), NITERDONE, EXITSTATUS, DLIST(NATOMS)
DOUBLE PRECISION :: DDOT,STPMIN, ETOTALTMP, USEFRAC, STIME, FTIME, &
  &                 ETOTAL, RMS, STEPTOT, LINTCONSTRAINTTOL, LXYZ(2*3*NATOMS), &
  &                 BESTWORST, WORST, COORDSA(3*NATOMS), COORDSB(3*NATOMS), DIST   !!! , LASTGOODE, COORDSC(3*NATOMS)
DOUBLE PRECISION, DIMENSION(INTMUPDATE)     :: RHO1,ALPHA
DOUBLE PRECISION :: EOLD, DMOVED(NATOMS)
LOGICAL SWITCHED, AABACK(NATOMS), BACKDONE
DOUBLE PRECISION, POINTER :: X(:), G(:)
DOUBLE PRECISION LDISTANCE,RMAT(3,3),CMXA,CMYA,CMZA,CMXB,CMYB,CMZB,TEMPB(3*NATOMS)
INTEGER  MAXNSETS
! efk: for freezenodes
!
DOUBLE PRECISION :: TESTG, TOTGNORM
INTEGER :: IM
!
! Dimensions involving INTIMAGE
!
DOUBLE PRECISION, ALLOCATABLE :: TRUEEE(:), &
  &              EEETMP(:), MYGTMP(:), EEE(:), STEPIMAGE(:), &
  &              GTMP(:), DIAG(:), STP(:), SEARCHSTEP(:,:), GDIF(:,:), GLAST(:), XSAVE(:)
DOUBLE PRECISION, ALLOCATABLE :: VPLUS(:), VMINUS(:)   
!DOUBLE PRECISION  EPLUS, EMINUS, DIFF   
DOUBLE PRECISION, ALLOCATABLE, TARGET :: XYZ(:), GGG(:), DPTMP(:), D2TMP(:,:)
! saved interpolation
INTEGER NITERUSE
LOGICAL, ALLOCATABLE :: CHECKG(:), IMGFREEZE(:)
INTEGER, ALLOCATABLE :: NCONATOM(:), CONLIST(:,:)
LOGICAL READIMAGET, INLIST(NATOMS)
LOGICAL, ALLOCATABLE :: GROUPACTIVE(:)
INTEGER LUNIT, GETUNIT
CHARACTER(LEN=2) SDUMMY
INTEGER JMAXEEE,num_chiral_centres,atom_number,MAXCONSTRAINTS,PATOM1,PATOM2,PATOMTEST,NCOMMONMAX 
DOUBLE PRECISION MAXEEE,MAXRMS,MINEEE,SAVELOCALPERMCUT
INTEGER SAVELOCALPERMNEIGH, PERM(NATOMS), NMOVE
DOUBLE PRECISION SAVELOCALPERMCUT2, DISTANCE, SAVEORBITTOL, DWORST, DELTAX(3*NATOMS)
CHARACTER(LEN=5) DUMMYZ
CHARACTER(LEN=80) :: FNAME

BOXLX=PARAM1;BOXLY=PARAM2;BOXLZ=PARAM3  ! otherwise box lengths were uninitialised and zero

WHOLEDNEB=.FALSE.
READIMAGET=.FALSE.
REMOVEIMAGE=.FALSE.
ECON=0.0D0; EREP=0.0D0; ESPRING=0.0D0
CCABSPHASE2=.FALSE.
CONCUTABSSAVE=CONCUTABS
CONCUTABSSAVE2=CONCUTABS2
MAXCONESAVE=MAXCONE
INTRMSTOLSAVE=INTRMSTOL
KINTSAVE=KINT
CONCUTABSINC=.FALSE.

WRITE(*,'(A,F12.6)') ' intlbfgs> extra distance before turning on constraint potential is initially ',CONCUTABS

!
! Use alternative perm allow list during QCI
!
IF (QCIPERMT) THEN 
   NPERMSIZE(1:3*NATOMS)=NPERMSIZEQCI(1:3*NATOMS)
   PERMGROUP(1:3*NATOMS)=PERMGROUPQCI(1:3*NATOMS)
   NSETS(1:3*NATOMS)=NSETSQCI(1:3*NATOMS)
   MAXNSETS=SIZE(SETS,2)
   NPERMGROUP=NPERMGROUPQCI
   SETS(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)=SETSQCI(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)
   NDUMMY=1
   IF (DEBUG) THEN
      WRITE(*,'(2(A,I6))') ' intlbfgs> we now have ',NPERMGROUP,' groups of permutable atoms with maximum sets=',MAXNSETS  
      DO J1=1,NPERMGROUP
         PRINT '(A,3(I6,A))',' keyword> group ',J1,' contains ',NPERMSIZE(J1),' atoms with ', &
     &                         NSETS(J1),' additional atom sets:'
         WRITE(*,'(22I6)',ADVANCE='NO') PERMGROUP(NDUMMY:NDUMMY+NPERMSIZE(J1)-1)
         IF (NSETS(J1).GT.0) THEN
            WRITE(*,'(A)',ADVANCE='NO') ' with '
            DO J2=1,NSETS(J1)
               DO J3=NDUMMY,NDUMMY+NPERMSIZE(J1)-1
                  WRITE(*,'(I6)',ADVANCE='NO') SETS(PERMGROUP(J3),J1,J2)
                  IF (J3.LT.NDUMMY+NPERMSIZE(J1)-1) WRITE(*,'(A3)',ADVANCE='NO') ' / '
               ENDDO
               IF (J2.LT.NSETS(J1)) WRITE(*,'(A3)',ADVANCE='NO') ' ; '
            ENDDO
        ENDIF
        PRINT *,' '
        NDUMMY=NDUMMY+NPERMSIZE(J1)
     ENDDO
  ENDIF
ENDIF

num_chiral_centres=-1
IF (QCIAMBERT) THEN ! copied from corresponding chirality subroutine
   num_chiral_centres=SIZE(sr_atoms,1)
   WRITE(*,'(A,I8)') ' intlbfgs> Number of chiral sites=',num_chiral_centres
ENDIF
! allocate and initilaise atomstores - needs to be allocated even if not used.
IF (.NOT. ALLOCATED(ATOMSTORES)) THEN
   IF (DEBUG) WRITE(*,'(A,I8)') 'intlbfgs> Allocating and intialising atomstores'
   ALLOCATE(ATOMSTORES(NATOMS))
   DO J1=1,NATOMS
      ATOMSTORES(J1)=0
   ENDDO
ENDIF

NCONOFF=0
AABACK(1:NATOMS)=.FALSE.
BACKDONE=.FALSE.
IF (DOBACK) THEN
   LUNIT=GETUNIT()
   OPEN(UNIT=LUNIT,FILE='aabk',STATUS='OLD')
   DO J1=1,NATOMS
      READ(LUNIT,*,END=861) NDUMMY
      AABACK(NDUMMY)=.TRUE.
   ENDDO
861   CLOSE(LUNIT)
ENDIF

IF (QCIRESTART) READIMAGET=.TRUE.
IF (QCIREADGUESS) READIMAGET=.TRUE.
IF (READIMAGET) THEN
   LUNIT=GETUNIT()
   FNAME='int.xyz'
   IF (QCIREADGUESS) FNAME=TRIM(ADJUSTL(QCIGUESSFILE))
   OPEN(UNIT=LUNIT,FILE=FNAME,STATUS='OLD')
   INTIMAGE=0
653 CONTINUE
   READ(LUNIT,*,END=654) NDUMMY
   READ(LUNIT,*) 
   DO J1=1,NATOMS
      READ(LUNIT,*) SDUMMY
   ENDDO
   INTIMAGE=INTIMAGE+1
   GOTO 653
654 CONTINUE
   INTIMAGE=INTIMAGE-2
   WRITE(*,'(A,I10,A)') ' intlbfgs> Rereading ',INTIMAGE,' frames'
   CLOSE(LUNIT)
!
! Need to change number of images here if required, before INTIMAGE allocations immediately below.
!
   IF (INTIMAGENEW.GT.INTIMAGE) THEN
      PRINT '(A)',' intlbfgs> need to change dimensions here'
      STOP
   ENDIF
ENDIF

IF (QCIIMAGEDENST) THEN
   CALL NEWMINDIST2(QSTART,QFINISH,NATOMS,LDISTANCE,DEBUG,RMAT,CMXA,CMYA,CMZA,CMXB,CMYB,CMZB,DWORST)
   INTIMAGE=MIN(IMDENSITY*LDISTANCE,1.0D0*MAXINTIMAGE)
   PRINT '(3(A,G20.10))',' intlbfgs> End minima distance=',LDISTANCE,' density ',IMDENSITY,' images set to ',INTIMAGE
   QCIIMAGE=INTIMAGE
ENDIF

ALLOCATE(TRUEEE(INTIMAGE+2), &
  &      EEETMP(INTIMAGE+2), MYGTMP(3*NATOMS*INTIMAGE), &
  &      GTMP(3*NATOMS*INTIMAGE), &
  &      DIAG(3*NATOMS*INTIMAGE), STP(3*NATOMS*INTIMAGE), SEARCHSTEP(0:INTMUPDATE,(3*NATOMS)*INTIMAGE), &
  &      GDIF(0:INTMUPDATE,(3*NATOMS)*INTIMAGE),GLAST((3*NATOMS)*INTIMAGE), XSAVE((3*NATOMS)*INTIMAGE), &
  &      XYZ((3*NATOMS)*(INTIMAGE+2)), GGG((3*NATOMS)*(INTIMAGE+2)), CHECKG((3*NATOMS)*INTIMAGE), IMGFREEZE(INTIMAGE), &
  &      EEE(INTIMAGE+2), STEPIMAGE(INTIMAGE))
ALLOCATE(VPLUS((3*NATOMS)*(INTIMAGE+2)),VMINUS((3*NATOMS)*(INTIMAGE+2)))  

SWITCHED=.FALSE.
INTIMAGESAVE=INTIMAGE
NBACKTRACK=1
CALL MYCPU_TIME(STIME,.FALSE.)
WRITE(*,'(A,I6)') ' intlbfgs> Maximum number of steps for constraint potential phase is ',INTSTEPS1
WRITE(*,'(A,I6,A,G20.10)') ' intlbfgs> Updates: ',INTMUPDATE,' maximum step size=',MAXINTBFGS
ADDATOM=.FALSE.
NFAIL=0
IMGFREEZE(1:INTIMAGE)=.FALSE.
D=(3*NATOMS)*INTIMAGE
U=INTMUPDATE
NITERDONE=1
NITERUSE=1

IF ( D<=0 ) THEN
   WRITE(*,*) 'd is not positive, d=',d
   STOP
ENDIF
IF ( U<=0 ) THEN
   WRITE(*,*) 'u is not positive, u=',u
   STOP
ENDIF
IF (INTSTEPS1 < 0) THEN
   WRITE(*,'(1x,a)') 'Maximal number of iterations is less than zero! Stop.'
   STOP
ENDIF
!
! XYZ, GGG, EEE include the end point images
! X, G do not.
!
IF (.NOT.ALLOCATED(CONI)) THEN 
   ALLOCATE(CONI(INTCONMAX),CONJ(INTCONMAX),CONDISTREF(INTCONMAX),CONCUT(INTCONMAX),CONOFFLIST(INTCONMAX),CONOFFTRIED(INTCONMAX))
   CONOFFTRIED(1:INTCONMAX)=.FALSE.
   ALLOCATE(REPI(NREPMAX),REPJ(NREPMAX),NREPI(NREPMAX),NREPJ(NREPMAX),REPCUT(NREPMAX),NREPCUT(NREPMAX))
ENDIF
X=>XYZ((3*NATOMS)+1:(3*NATOMS)*(INTIMAGE+1))
G=>GGG((3*NATOMS)+1:(3*NATOMS)*(INTIMAGE+1))

IF (QCIALIGN) THEN ! align on atoms in QCIalign file - there are QCIALIGNN of them in QCIALIGNATOMS

   DO J1=1,QCIALIGNN
      COORDSA(3*(J1-1)+1:3*(J1-1)+3)=QSTART(3*(QCIALIGNATOMS(J1)-1)+1:3*(QCIALIGNATOMS(J1)-1)+3)
      COORDSB(3*(J1-1)+1:3*(J1-1)+3)=QFINISH(3*(QCIALIGNATOMS(J1)-1)+1:3*(QCIALIGNATOMS(J1)-1)+3)
   ENDDO
   CALL NEWMINDIST2(COORDSA,COORDSB,QCIALIGNN,LDISTANCE,DEBUG,RMAT,CMXA,CMYA,CMZA,CMXB,CMYB,CMZB,DWORST)
   PRINT '(A,I8,A,G20.10,A,G20.10)',' intlbfgs> After aligning the ',QCIALIGNN,' specified atoms distance=',LDISTANCE, &
  &        ' and worst atom displacement=',DWORST  
!
! Now align all the atoms the same way
!
   DO J2=1,NATOMS
      TEMPB(3*(J2-1)+1)=QFINISH(3*(J2-1)+1)-CMXB+CMXA
      TEMPB(3*(J2-1)+2)=QFINISH(3*(J2-1)+2)-CMYB+CMYA
      TEMPB(3*(J2-1)+3)=QFINISH(3*(J2-1)+3)-CMZB+CMZA
   ENDDO
   CALL NEWROTGEOM(NATOMS,TEMPB,RMAT,CMXA,CMYA,CMZA)
   QFINISH(1:3*NATOMS)=TEMPB(1:3*NATOMS)
   DEALLOCATE(QCIALIGNATOMS)
!
! Identify largest possible subregions that preserve geometry within some tolerance. 
! The idea is to try and get as many frozen atoms as possible.
! LOCALPERMNEIGH 11 maximum neighbours - set to min(LOCALPERMNEIGH,NATOMS)
! LOCALPERMCUT 0.5 alignment threshold - atoms not added if the alignment is worse than this in terms of the total Euclidean distance
!              don't we really want the worst distance for one atom? We are comparing to an extensive quantity!
! LOCALPERMCUT2 5.0 atoms to add to group must be within this distance (averaged for end points)
! ORBITTOL 0.5D0 Distance tolerance for distinguishing atoms in the same orbit
!
ELSEIF (PERMDIST.AND.(.NOT.QCIREADGUESS).AND.(.NOT.USEFRACT)) THEN ! this scheme won't work without at least one permutable group of atoms.
   SAVELOCALPERMNEIGH=LOCALPERMNEIGH
   SAVELOCALPERMCUT=LOCALPERMCUT
   SAVELOCALPERMCUT2=LOCALPERMCUT2
   SAVEORBITTOL=ORBITTOL
   LOCALPERMNEIGH=NATOMS
   LOCALPERMCUT=1.2D0
   LOCALPERMCUT2=1.0D10
   IF (BOXDERIVT) LOCALPERMCUT=0.2D0
   ORBITTOL=0.3D0
   LPERMOFF=.TRUE.
   PRINT '(A)',' intlbfgs> calling lopermdist for regional alignment before checking for atom displacements between end minima'
   CALL LOPERMDIST(QSTART,QFINISH,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,BULKT,TWOD,DISTANCE,DIST2,.FALSE.,RMATBEST,0,NMOVE,PERM)
   LOCALPERMNEIGH=SAVELOCALPERMNEIGH
   LOCALPERMCUT=SAVELOCALPERMCUT
   LOCALPERMCUT2=SAVELOCALPERMCUT2
   ORBITTOL=SAVEORBITTOL
   LPERMOFF=.FALSE.
ENDIF
IF (USEFRACT) THEN
!
! We should have a roughly minimised distance between start and finish for minimum image.
! Interpolate between them using the minimum image vector
!
! We need to interpolate along the minimum image vector - we don't want the minimum image of the other point

  DO J2=1,NATOMS
      QFINISH(3*(J2-1)+1)=QFINISH(3*(J2-1)+1)-BOXLX*NINT((QFINISH(3*(J2-1)+1)-QSTART(3*(J2-1)+1))/BOXLX)
      QFINISH(3*(J2-1)+2)=QFINISH(3*(J2-1)+2)-BOXLY*NINT((QFINISH(3*(J2-1)+2)-QSTART(3*(J2-1)+2))/BOXLY)
      QFINISH(3*(J2-1)+3)=QFINISH(3*(J2-1)+3)-BOXLZ*NINT((QFINISH(3*(J2-1)+3)-QSTART(3*(J2-1)+3))/BOXLZ)
   ENDDO
ENDIF
!
! Initialise XYZ
!
IF (READIMAGET) THEN  ! Note that this will ignore the coordinates in start and finish - changed to overwrite start and finish
   LUNIT=GETUNIT()
   OPEN(UNIT=LUNIT,FILE=FNAME,STATUS='OLD')
   DO J2=1,INTIMAGE+2
      READ(LUNIT,*) NDUMMY
      READ(LUNIT,*) 
      DO J1=1,NATOMS
         READ(LUNIT,*) SDUMMY,XYZ(3*NATOMS*(J2-1)+3*(J1-1)+1),XYZ(3*NATOMS*(J2-1)+3*(J1-1)+2),XYZ(3*NATOMS*(J2-1)+3*(J1-1)+3)
      ENDDO
   ENDDO
   CLOSE(LUNIT)
   IF (INTIMAGENEW.GT.INTIMAGE) THEN
      PRINT '(A)',' intlbfgs> need to redistribute images here'
      STOP
   ENDIF
ELSE
   XYZ(1:(3*NATOMS))=QSTART(1:(3*NATOMS))
   XYZ((3*NATOMS)*(INTIMAGE+1)+1:(3*NATOMS)*(INTIMAGE+2))=QFINISH(1:(3*NATOMS))
   DO J1=1,INTIMAGE+2
      XYZ((J1-1)*(3*NATOMS)+1:J1*(3*NATOMS))=((INTIMAGE+2-J1)*QSTART(1:(3*NATOMS))+(J1-1)*QFINISH(1:(3*NATOMS)))/(INTIMAGE+1)
   ENDDO
!!!!!!!!!!!!!! debug DJW
LUNIT=GETUNIT()
OPEN(UNIT=LUNIT,FILE='linear.xyz',STATUS='replace')
DO J2=1,INTIMAGE+2
   WRITE(LUNIT,'(i4/)') NATOMS
   DO J3=1,NATOMS
         WRITE(LUNIT,'(A5,1X,3F20.10)') 'LA   ',XYZ((J2-1)*3*NATOMS+3*(J3-1)+1),XYZ((J2-1)*3*NATOMS+3*(J3-1)+2), &
  &                                                                   XYZ((J2-1)*3*NATOMS+3*(J3-1)+3)
   ENDDO
ENDDO
CLOSE(LUNIT)
   WORST=0.0D0
   IF (.NOT.ALLOCATED(ATOMACTIVE)) ALLOCATE(ATOMACTIVE(NATOMS))
   ATOMACTIVE(1:NATOMS)=.FALSE.
!  GOTO 678
!   STOP
!!!!!!!!!!!!!! debug DJW
ENDIF

IF (ALLOCATED(INTFROZEN)) DEALLOCATE(INTFROZEN)
ALLOCATE(INTFROZEN(NATOMS))
NQCIFREEZE=0
INTFROZEN(1:NATOMS)=.FALSE.

DLIST(1:NATOMS)=-1
DMOVED(1:NATOMS)=1.0D100
IF (INTFREEZET) THEN
   DUMMY=INTFREEZETOL**2
   DO J1=1,NATOMS
      DF=(XYZ(3*(J1-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+1))**2 &
  &     +(XYZ(3*(J1-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+2))**2 &
  &     +(XYZ(3*(J1-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+3))**2
      IF ((DF.LT.DUMMY).OR.FROZEN(J1)) THEN
         NQCIFREEZE=NQCIFREEZE+1
         INTFROZEN(J1)=.TRUE.
         IF (DEBUG) WRITE(*,'(A,I6,A,F12.6,A,I6)') &
  &            ' intlbfgs> atom ',J1,' moves less than threshold: dist^2=',DF,' total=',NQCIFREEZE
      ENDIF
      sortd: DO J2=1,J1
         IF (DF.LT.DMOVED(J2)) THEN
            DO J3=J1,J2+1,-1
               DMOVED(J3)=DMOVED(J3-1)
               DLIST(J3)=DLIST(J3-1)
            ENDDO
            DMOVED(J2)=DF
            DLIST(J2)=J1
            EXIT sortd
         ENDIF
      ENDDO sortd
   ENDDO
   WRITE(*,'(A,I6,A,F12.6,A,I6)') ' intlbfgs> Total number of atoms moving less than threshold=',NQCIFREEZE
ENDIF

IF (NATOMS-NQCIFREEZE.LT.INTFREEZEMIN) THEN ! we have to have INTFREEZEMIN atoms unfrozen
   DO J1=NATOMS,NATOMS-INTFREEZEMIN+1,-1    ! unfreeze some of them
      INTFROZEN(DLIST(J1))=.FALSE.
   ENDDO
   NQCIFREEZE=MAX(0,NATOMS-INTFREEZEMIN)
   WRITE(*,'(A,I6,A)') ' intlbfgs> Freezing ',NQCIFREEZE,' atoms'
ENDIF


NLASTGOODE=0
!NLASTCHANGE=0
!LASTGOODE=1.0D100

!
! Constraints are collected in a list and activated via the CONACTIVE(J1)
! logical array. There will generally be of order NATOMS. However, the
! repulsions will scale as NATOMS**2 and are treated differently. The
! active repulsions are stored sequentially as atoms are added to the
! growing list. This is done even if we have congeom or congeom.dat files
! available. In this case we use the fixed list of possible constraints
! via CHECKPERC, but the list of repulsions and cutoffs is recreated on
! the fly. The fixed lists are used in make_conpot, since this is called
! for pairs of minima with all atoms active to obtain an interpolation
! metric.
!
! Perhaps we should use the fixed list to activate the repulsions below?
! A neighbour list for repulsions is maintained to make the constraint
! potential evaluation scale as order N.
!

IF (NQCIFREEZE.LT.NATOMS) THEN
   LXYZ(1:(3*NATOMS))=QSTART(1:(3*NATOMS))
   LXYZ((3*NATOMS)+1:2*(3*NATOMS))=QFINISH(1:(3*NATOMS))
   CALL CHECKPERC(LXYZ,LINTCONSTRAINTTOL,NQCIFREEZE,2)
ELSE
   IF (.NOT.ALLOCATED(ATOMACTIVE)) ALLOCATE(ATOMACTIVE(NATOMS))
   NCONSTRAINT=0
   WRITE(*,'(A)') ' intlbfgs> All atoms move less than threshold - skip to linear interpolation for end points'
   INTIMAGE=0
   XYZ(1:(3*NATOMS))=QSTART(1:(3*NATOMS))
   XYZ((3*NATOMS)*(INTIMAGE+1)+1:(3*NATOMS)*(INTIMAGE+2))=QFINISH(1:(3*NATOMS))
   DO J1=1,INTIMAGE+2
      XYZ((J1-1)*(3*NATOMS)+1:J1*(3*NATOMS))=((INTIMAGE+2-J1)*QSTART(1:(3*NATOMS))+(J1-1)*QFINISH(1:(3*NATOMS)))/(INTIMAGE+1)
   ENDDO
   GOTO 678
ENDIF

IF (ALLOCATED(NCONATOM)) DEALLOCATE(NCONATOM)
ALLOCATE(NCONATOM(NATOMS))
NCONATOM(1:NATOMS)=0
DO J1=1,NCONSTRAINT
   NCONATOM(CONI(J1))=NCONATOM(CONI(J1))+1
   NCONATOM(CONJ(J1))=NCONATOM(CONJ(J1))+1
ENDDO
MAXCONSTRAINTS=-1
DO J1=1,NATOMS
   IF (NCONATOM(J1).GT.MAXCONSTRAINTS) THEN
      WRITE(*,*) NCONATOM(J1)
      MAXCONSTRAINTS=NCONATOM(J1)
      J2=J1
   ENDIF
ENDDO
WRITE(*,'(A,I6,A,I6)') ' intlbfgs> maximum constraints ',MAXCONSTRAINTS,' for atom ',J2
IF (ALLOCATED(CONLIST)) DEALLOCATE(CONLIST)
ALLOCATE(CONLIST(NATOMS,MAXCONSTRAINTS))
CONLIST(1:NATOMS,1:MAXCONSTRAINTS)=0
NCONATOM(1:NATOMS)=0
DO J1=1,NCONSTRAINT
   NCONATOM(CONI(J1))=NCONATOM(CONI(J1))+1
   NCONATOM(CONJ(J1))=NCONATOM(CONJ(J1))+1
   CONLIST(CONI(J1),NCONATOM(CONI(J1)))=CONJ(J1)
   CONLIST(CONJ(J1),NCONATOM(CONJ(J1)))=CONI(J1)
ENDDO


NDUMMY=1 ! counter for position of entries for successive permutational groups, size NPERMSIZE(J1)
NCOMMONMAX=-1 ! work out the largest number of common constraints for any permutational group 
IF (ALLOCATED(NCONCOMMON)) DEALLOCATE(NCONCOMMON)
ALLOCATE(NCONCOMMON(NPERMGROUP))
DO J1=1,NPERMGROUP
   NCONCOMMON(J1)=0
   PATOM1=PERMGROUP(NDUMMY)

! For each entry in constraint list of first permutable atom, check if it exists for the second, 
! if so, check the third, etc.
!
   atlist: DO J4=1,NCONATOM(PATOM1)
      PATOMTEST=CONLIST(PATOM1,J4)
      plist: DO J5=2,NPERMSIZE(J1)
         PATOM2=PERMGROUP(NDUMMY+J5-1)
         DO J6=1,NCONATOM(PATOM2)
            IF (CONLIST(PATOM2,J6).EQ.PATOMTEST) CYCLE plist
         ENDDO
         CYCLE atlist
      ENDDO plist
      NCONCOMMON(J1)=NCONCOMMON(J1)+1
      DO J5=1,NPERMSIZE(J1)
         J6=PERMGROUP(NDUMMY+J5-1)
      ENDDO
   ENDDO atlist
   NDUMMY=NDUMMY+NPERMSIZE(J1)
   IF (NCONCOMMON(J1).GT.NCOMMONMAX) NCOMMONMAX=NCONCOMMON(J1)
ENDDO
IF (ALLOCATED(COMMONCON)) DEALLOCATE(COMMONCON)
ALLOCATE(COMMONCON(NPERMGROUP,NCOMMONMAX))

WRITE(*,'(A,I6)') ' intlbfgs> largest number of common constraint atoms for any group is: ',NCOMMONMAX
!
! Now repeat and save the common constrained atoms in COMMONCON(J1,1:NCOMMONCON(J1)) for permutational group J1.
!
NDUMMY=1
DO J1=1,NPERMGROUP
   NCONCOMMON(J1)=0
   PATOM1=PERMGROUP(NDUMMY)
!
! For each entry in constraint list of first permutable atom, check if it exists for the second, 
! if so, check the third, etc.
!
   atlist2: DO J4=1,NCONATOM(PATOM1)
      PATOMTEST=CONLIST(PATOM1,J4)
      plist2: DO J5=2,NPERMSIZE(J1)
         PATOM2=PERMGROUP(NDUMMY+J5-1)
         DO J6=1,NCONATOM(PATOM2)
            IF (CONLIST(PATOM2,J6).EQ.PATOMTEST) CYCLE plist2
         ENDDO
         CYCLE atlist2
      ENDDO plist2
      NCONCOMMON(J1)=NCONCOMMON(J1)+1 
      COMMONCON(J1,NCONCOMMON(J1))=PATOMTEST
      DO J5=1,NPERMSIZE(J1)
         J6=PERMGROUP(NDUMMY+J5-1)
      ENDDO
   ENDDO atlist2
   NDUMMY=NDUMMY+NPERMSIZE(J1)
ENDDO

NACTIVE=0
TURNONORDER(1:NATOMS)=0
ATOMACTIVE(1:NATOMS)=.FALSE.
REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT**6 ! also needed for congrad.f90 potential
IF (QCIRESTART) THEN
   QCIRESTART=.FALSE.
   LUNIT=GETUNIT()
   OPEN(UNIT=LUNIT,FILE='QCIdump',STATUS='OLD')

   READ(LUNIT,*) NACTIVE
   WRITE(*,'(A,I10,A)') ' intlbfgs> restart has ',NACTIVE,' active atoms'
   READ(LUNIT,*) KINT, INTCONSTRAINTREP
   WRITE(*,'(A,2G20.10)') ' intlbfgs> spring constant and repulsive prefactor: ',KINT, INTCONSTRAINTREP
   WRITE(*,'(A)') ' intlbfgs> reading turnonorder'
   READ(LUNIT,*) TURNONORDER(1:NACTIVE)
   WRITE(*,'(A)') ' intlbfgs> reading atomactive'
   READ(LUNIT,*) ATOMACTIVE(1:NATOMS)
   READ(LUNIT,*) NCONSTRAINT
   WRITE(*,'(A)') ' intlbfgs> reading conactive'
   WRITE(*,'(A,I10,A)') ' intlbfgs> restart has ',NCONSTRAINT,' constraints'
   ALLOCATE(CONACTIVE(NCONSTRAINT))
   READ(LUNIT,*) CONACTIVE(1:NCONSTRAINT)

   ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
   ALLOCATE(CONCUTLOCAL(NCONSTRAINT))
   CONDISTREFLOCAL(1:NCONSTRAINT)=CONDISTREF(1:NCONSTRAINT)
   CONCUTLOCAL(1:NCONSTRAINT)=CONCUT(1:NCONSTRAINT)

   READ(LUNIT,*) NREPULSIVE,NNREPULSIVE,NREPMAX
   USEFRAC=1.0D0
   IF (ALLOCATED(REPI)) DEALLOCATE(REPI)
   IF (ALLOCATED(REPJ)) DEALLOCATE(REPJ)
   IF (ALLOCATED(NREPI)) DEALLOCATE(NREPI)
   IF (ALLOCATED(NREPJ)) DEALLOCATE(NREPJ)
   IF (ALLOCATED(REPCUT)) DEALLOCATE(REPCUT)
   IF (ALLOCATED(NREPCUT)) DEALLOCATE(NREPCUT)
   ALLOCATE(REPI(NREPMAX),REPJ(NREPMAX),NREPI(NREPMAX),NREPJ(NREPMAX),REPCUT(NREPMAX),NREPCUT(NREPMAX))
   READ(LUNIT,*) REPI(1:NREPULSIVE)
   WRITE(*,'(A)') ' intlbfgs> read REPI:'
!  WRITE(*,'(12I8)') REPI(1:NREPULSIVE)
   READ(LUNIT,*) REPJ(1:NREPULSIVE)
   WRITE(*,'(A)') ' intlbfgs> read REPJ:'
!  WRITE(*,'(12I8)') REPJ(1:NREPULSIVE)
   READ(LUNIT,*) NREPI(1:NNREPULSIVE)
   WRITE(*,'(A)') ' intlbfgs> read NREPI:'
!  WRITE(*,'(12I8)') NREPI(1:NNREPULSIVE)
   READ(LUNIT,*) NREPJ(1:NNREPULSIVE)
   WRITE(*,'(A)') ' intlbfgs> read NREPJ:'
!  WRITE(*,'(12I8)') NREPJ(1:NNREPULSIVE)
   READ(LUNIT,*) REPCUT(1:NREPULSIVE)
   WRITE(*,'(A)') ' intlbfgs> read REPCUT:'
!  WRITE(*,'(6G20.10)') REPCUT(1:NREPULSIVE)
   READ(LUNIT,*) NREPCUT(1:NNREPULSIVE)
   WRITE(*,'(A)') ' intlbfgs> read NREPCUT:'
!  WRITE(*,'(6G20.10)') NREPCUT(1:NNREPULSIVE)
   READ(LUNIT,*) INTFROZEN(1:NATOMS)
   WRITE(*,'(A)') ' intlbfgs> read INTFROZEN'
!  WRITE(*,'(12L5)') INTFROZEN(1:NATOMS)

   NCONOFF=0
   READ(LUNIT,*,END=742) NCONOFF
   IF (NCONOFF.GT.0) READ(LUNIT,*) CONOFFLIST(1:NCONOFF)
   IF (NCONOFF.GT.0) READ(LUNIT,*) CONOFFTRIED(1:NCONSTRAINT)
742 CONTINUE
   CLOSE(LUNIT)

   GLAST(1:D)=G(1:D)
   XSAVE(1:D)=X(1:D)
   GOTO 986
ENDIF
IF (INTFREEZET) THEN
   DO J1=1,NATOMS
      IF (INTFROZEN(J1)) THEN
! 
! linear interpolation 
! 
         DO J2=2,INTIMAGE+1
            XYZ((J2-1)*3*NATOMS+3*(J1-1)+1:(J2-1)*3*NATOMS+3*(J1-1)+3)= &
  &            (INTIMAGE-J2+2)*XYZ(3*(J1-1)+1:3*(J1-1)+3)/(INTIMAGE+1) &
  &           +(J2-1)*XYZ(3*NATOMS*(INTIMAGE+1)+3*(J1-1)+1:3*NATOMS*(INTIMAGE+1)+3*(J1-1)+3)/(INTIMAGE+1)
         ENDDO
         ATOMACTIVE(J1)=.TRUE.
         NACTIVE=NACTIVE+1
         TURNONORDER(NACTIVE)=J1
         NTRIES(J1)=1
      ENDIF
   ENDDO
ENDIF

IF (QCIREADGUESS) THEN
   NACTIVE=NATOMS
   TURNONORDER(1:NATOMS)=0 ! not needed if all active
   ATOMACTIVE(1:NATOMS)=.TRUE.
ENDIF


REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT**6 ! also needed for congrad.f90 potential
IF (ALLOCATED(CONDISTREFLOCAL)) DEALLOCATE(CONDISTREFLOCAL)
IF (ALLOCATED(CONCUTLOCAL)) DEALLOCATE(CONCUTLOCAL)
ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
ALLOCATE(CONCUTLOCAL(NCONSTRAINT))
IF (ALLOCATED(CONDISTREFLOCALON)) DEALLOCATE(CONDISTREFLOCALON)
IF (ALLOCATED(CONDISTREFON)) DEALLOCATE(CONDISTREFON)
IF (ALLOCATED(CONION)) DEALLOCATE(CONION)
IF (ALLOCATED(CONJON)) DEALLOCATE(CONJON)
ALLOCATE(CONDISTREFLOCALON(NCONSTRAINT),CONDISTREFON(NCONSTRAINT),CONION(NCONSTRAINT),CONJON(NCONSTRAINT))
CONDISTREFLOCAL(1:NCONSTRAINT)=CONDISTREF(1:NCONSTRAINT)
CONCUTLOCAL(1:NCONSTRAINT)=CONCUT(1:NCONSTRAINT)
DUMMY=1.0D100
DUMMYDOBACK=1.0D100
DUMMY2=-1.0D100
IF (NCONSTRAINT.EQ.0) THEN
   NACTIVE=NATOMS
   EOLD=ETOTAL
   SWITCHED=.TRUE.
   USEFRAC=1.0D0
   NREPULSIVE=0
   NNREPULSIVE=0
   GLAST(1:D)=G(1:D)
   XSAVE(1:D)=X(1:D)
   GOTO 567
ENDIF
!
! bug occured for QCIDOBACKALL when some atoms (206/220) move less than the threshold, so they are fixed. 
! Then the search for a pair of atoms that are constrained where both are in the backbone set fails and NBEST was not set.
!
! If QCILINEARLIST choose two atoms from the list to begin with
!
INLIST(1:NATOMS)=.FALSE.
IF (QCILINEARLIST) THEN
   DO J1=1,QCILINEARN
      IF (INTFROZEN(QCILINEARATOMS(J1))) THEN
         PRINT*,'intlbfgs atom ',QCILINEARATOMS(J1),' is in the linear list but moves less than threshold, already active and linear interpolated'
      ELSE
         INLIST(QCILINEARATOMS(J1))=.TRUE.
         PRINT*,'intlbfgs atom ',QCILINEARATOMS(J1),' is in the linear list'
      ENDIF
   ENDDO
ENDIF
NBESTDOBACK=-1
DO J1=1,NCONSTRAINT
!  IF (DOBACK.AND.(.NOT.AABACK(CONI(J1)).OR.(.NOT.AABACK(CONJ(J1))))) CYCLE
   IF (QCILINEARLIST.AND.(.NOT.INLIST(CONI(J1)).OR.(.NOT.INLIST(CONJ(J1))))) CYCLE
   DF=SQRT((XYZ(3*(CONI(J1)-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONI(J1)-1)+1))**2 &
  &       +(XYZ(3*(CONI(J1)-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONI(J1)-1)+2))**2 &
  &       +(XYZ(3*(CONI(J1)-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONI(J1)-1)+3))**2)&
  &  +SQRT((XYZ(3*(CONJ(J1)-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONJ(J1)-1)+1))**2 &
  &       +(XYZ(3*(CONJ(J1)-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONJ(J1)-1)+2))**2 &
  &       +(XYZ(3*(CONJ(J1)-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONJ(J1)-1)+3))**2)
   IF (DF.LT.DUMMY) THEN
      NBEST=J1
      DUMMY=DF
   ENDIF
   IF (DF.LT.DUMMYDOBACK) THEN
      IF (DOBACK.AND.AABACK(CONI(J1)).AND.AABACK(CONJ(J1))) THEN
         NBESTDOBACK=J1
         DUMMYDOBACK=DF
      ENDIF
   ENDIF
   IF (DF.GT.DUMMY2) THEN
      NBEST2=J1
      DUMMY2=DF
   ENDIF
ENDDO
IF (DOBACK.AND.(NBESTDOBACK.GT.0)) NBEST=NBESTDOBACK  ! ensures NBEST is set if there are frozen atoms and DOBACK is set 
IF (DEBUG) WRITE(*,'(A,I6,A,2I6,A,F15.5)') ' intlbfgs> Smallest overall motion for constraint ',NBEST, ' atoms ', &
  &                           CONI(NBEST),CONJ(NBEST),' distance=',DUMMY
IF (DEBUG) WRITE(*,'(A,I6,A,2I6,A,F15.5)') ' intlbfgs> Largest overall motion for constraint  ',NBEST2,' atoms ', &
  &                           CONI(NBEST2),CONJ(NBEST2),' distance=',DUMMY2

!!! NBEST=NBEST2 !!!! DJW
NTRIES(1:NATOMS)=1
IF (ALLOCATED(CONACTIVE)) DEALLOCATE(CONACTIVE)
ALLOCATE(CONACTIVE(NCONSTRAINT))
CONACTIVE(1:NCONSTRAINT)=.FALSE.
IF (QCIREADGUESS) THEN
   CONACTIVE(1:NCONSTRAINT)=.TRUE.
!
! Set up repulsions.
!
   DO J1=1,NATOMS
      DO J3=J1+1,NATOMS
         IF (ABS(J1-J3).LE.INTREPSEP) CYCLE ! no repulsion for atoms too close in sequence
         DO J2=1,NCONSTRAINT
            IF (((CONI(J2).EQ.J1).AND.(CONJ(J2).EQ.J3)).OR.((CONJ(J2).EQ.J1).AND.(CONI(J2).EQ.J3))) GOTO 543
         ENDDO
         DMIN=1.0D100
         DO J2=1,INTIMAGE+2,INTIMAGE+1 ! only consider the end-point distances
            DF=SQRT((XYZ((J2-1)*3*NATOMS+3*(J3-1)+1)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+1))**2+ &
  &                 (XYZ((J2-1)*3*NATOMS+3*(J3-1)+2)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+2))**2+ &
  &                 (XYZ((J2-1)*3*NATOMS+3*(J3-1)+3)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+3))**2)
            IF (DF.LT.DMIN) DMIN=DF
         ENDDO
         DMIN=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
         NREPULSIVE=NREPULSIVE+1
         IF (NREPULSIVE.GT.NREPMAX) CALL REPDOUBLE
         REPI(NREPULSIVE)=J1
         REPJ(NREPULSIVE)=J3
         REPCUT(NREPULSIVE)=DMIN
543      CONTINUE
      ENDDO
   ENDDO
   CALL CHECKREP(INTIMAGE,XYZ,(3*NATOMS),0,1)
   GOTO 986 ! skip the usual starting setup for a pair of atoms
ENDIF
IF (NBEST.EQ.0) THEN
   PRINT '(A)',' intlbfgs> ERROR NBEST=0 - this should never happen'
   STOP
ENDIF
CONACTIVE(NBEST)=.TRUE.
ATOMACTIVE(CONI(NBEST))=.TRUE.
ATOMACTIVE(CONJ(NBEST))=.TRUE.
IF (DEBUG) WRITE(*,'(A,I6,A,2I6)') ' intlbfgs> Turning on constraint ',NBEST,' for atoms ',CONI(NBEST),CONJ(NBEST)
IF (.NOT.INTFROZEN(CONI(NBEST))) THEN
   TURNONORDER(NACTIVE+1)=CONI(NBEST)
   NACTIVE=NACTIVE+1
ENDIF
IF (.NOT.INTFROZEN(CONJ(NBEST))) THEN
   TURNONORDER(NACTIVE+1)=CONJ(NBEST)
   NACTIVE=NACTIVE+1
ENDIF
NTRIES(CONI(NBEST))=1
NTRIES(CONJ(NBEST))=1
NREPULSIVE=0
NCONSTRAINTON=1
CONDISTREFLOCALON(1)=CONDISTREFLOCAL(NBEST)
CONDISTREFON(1)=CONDISTREF(NBEST)
CONION(1)=CONI(NBEST)
CONJON(1)=CONJ(NBEST)
IF (DEBUG) WRITE(*,'(A,I6)') ' intlbfgs> Number of active atoms is now ',NACTIVE
!
! If INTFREEZET is true we need to add constraints and replusions to the frozen atoms.
! ATOMACTIVE is .TRUE. for frozen atoms.
!
IF (INTFREEZET) THEN
   DO J1=1,NCONSTRAINT
      IF (CONACTIVE(J1)) CYCLE
      IF ((CONI(J1).EQ.CONI(NBEST)).AND.(ATOMACTIVE(CONJ(J1))).OR.(CONJ(J1).EQ.CONI(NBEST)).AND.(ATOMACTIVE(CONI(J1)))) THEN
         CONACTIVE(J1)=.TRUE.
         IF (DEBUG) WRITE(*,'(A,I6,A,2I6)') ' intlbfgs> Turning on constraint ',J1,' for atoms ',CONI(J1),CONJ(J1)
      ENDIF
      IF ((CONI(J1).EQ.CONJ(NBEST)).AND.(ATOMACTIVE(CONJ(J1))).OR.(CONJ(J1).EQ.CONJ(NBEST)).AND.(ATOMACTIVE(CONI(J1)))) THEN
         CONACTIVE(J1)=.TRUE.
         IF (DEBUG) WRITE(*,'(A,I6,A,2I6)') ' intlbfgs> Turning on constraint ',J1,' for atoms ',CONI(J1),CONJ(J1)
      ENDIF
   ENDDO

   DO J1=1,NATOMS
      IF (.NOT.ATOMACTIVE(J1)) CYCLE ! identify active atoms
      IF (ABS(J1-CONI(NBEST)).LE.INTREPSEP) CYCLE ! no repulsion for atoms too close in sequence
      IF (INTFROZEN(J1).AND.INTFROZEN(CONI(NBEST))) CYCLE
      DO J2=1,NCONSTRAINT
!
!  With MAXCONUSE set to a finite value there could be constraints for the new atom that are
!  not active. We don't want these to be changed to repulsion, surely?!
!  Or perhaps we do need to do something with them?
!
         IF (.NOT.CONACTIVE(J2)) CYCLE ! repulsions for constraints
         IF (((CONI(J2).EQ.J1).AND.(CONJ(J2).EQ.CONI(NBEST))).OR.((CONJ(J2).EQ.J1).AND.(CONI(J2).EQ.CONI(NBEST)))) GOTO 545
      ENDDO
      DMIN=1.0D100
      DMAX=-1.0D0
      DO J2=1,INTIMAGE+2,INTIMAGE+1 ! only consider the end-point distances
         DF=SQRT((XYZ((J2-1)*3*NATOMS+3*(CONI(NBEST)-1)+1)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+1))**2+ &
  &           (XYZ((J2-1)*3*NATOMS+3*(CONI(NBEST)-1)+2)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+2))**2+ &
  &           (XYZ((J2-1)*3*NATOMS+3*(CONI(NBEST)-1)+3)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+3))**2)
         IF (DF.GT.DMAX) DMAX=DF
         IF (DF.LT.DMIN) DMIN=DF
      ENDDO
!
! Use the minimum of the end point distances and INTCONSTRAINREPCUT for each contact.
!
      DMIN=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
      NREPULSIVE=NREPULSIVE+1
      IF (NREPULSIVE.GT.NREPMAX) CALL REPDOUBLE
      REPI(NREPULSIVE)=J1
      REPJ(NREPULSIVE)=CONI(NBEST)
      REPCUT(NREPULSIVE)=DMIN
!     IF (DEBUG) WRITE(*,'(A,I6,A,I6,A,F15.5)') ' intlbfgs> Adding repulsion for new atom ',CONI(NBEST),' with atom ',J1, &
! &                                          ' cutoff=',DMIN
545   CONTINUE
   ENDDO

   DO J1=1,NATOMS
      IF (.NOT.ATOMACTIVE(J1)) CYCLE ! identify active atoms
      IF (ABS(J1-CONJ(NBEST)).LE.INTREPSEP) CYCLE ! no repulsion for atoms too close in sequence
      IF (INTFROZEN(J1).AND.INTFROZEN(CONJ(NBEST))) CYCLE
      DO J2=1,NCONSTRAINT
!
!  With MAXCONUSE set to a finite value there could be constraints for the new atom that are
!  not active. We don't want these to be changed to repulsion, surely?!
!  Or perhaps we do need to do something with them?
!
         IF (.NOT.CONACTIVE(J2)) CYCLE ! identify active constraints
         IF (((CONI(J2).EQ.J1).AND.(CONJ(J2).EQ.CONJ(NBEST))).OR.((CONJ(J2).EQ.J1).AND.(CONI(J2).EQ.CONJ(NBEST)))) GOTO 541
      ENDDO
      DMIN=1.0D100
      DMAX=-1.0D0
      DO J2=1,INTIMAGE+2,INTIMAGE+1 ! only consider the end-point distances
         DF=SQRT((XYZ((J2-1)*3*NATOMS+3*(CONJ(NBEST)-1)+1)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+1))**2+ &
  &           (XYZ((J2-1)*3*NATOMS+3*(CONJ(NBEST)-1)+2)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+2))**2+ &
  &           (XYZ((J2-1)*3*NATOMS+3*(CONJ(NBEST)-1)+3)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+3))**2)
         IF (DF.GT.DMAX) DMAX=DF
         IF (DF.LT.DMIN) DMIN=DF
      ENDDO
!
! Use the minimum of the end point distances and INTCONSTRAINREPCUT for each contact.
!
      DMIN=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
      NREPULSIVE=NREPULSIVE+1
      IF (NREPULSIVE.GT.NREPMAX) CALL REPDOUBLE
      REPI(NREPULSIVE)=J1
      REPJ(NREPULSIVE)=CONJ(NBEST)
      REPCUT(NREPULSIVE)=DMIN
!     IF (DEBUG) WRITE(*,'(A,I6,A,I6,A,F15.5)') ' intlbfgs> Adding repulsion for new atom ',CONJ(NBEST),' with atom ',J1, &
! &                                          ' cutoff=',DMIN
541   CONTINUE
   ENDDO
ENDIF ! end of block to add constraints and repulsions for frozen atoms.
CALL MYCPU_TIME(FTIME,.FALSE.)
WRITE(*,'(A,F10.1,A,I6)') ' intlbfgs> constrained potential finished, time=',FTIME-STIME,' number of repulsions=',NREPULSIVE
986 CONTINUE
STIME=FTIME
NSTEPSMAX=INTSTEPS1
!
! Don;t want to redistribute images before even taking a step, so don;t call CHECKSEP.
! Must call CHECKREP to initialise NNREULSIVE, NREPI, NREPJ, etc. SEGV otherwise on second cycle!
!
! To take BH-type steps in the QCI space, jump back here. Leave SWITCHED true.
!
BESTWORST=1.0D100
9876 CONTINUE
CALL CHECKREP(INTIMAGE,XYZ,(3*NATOMS),0,1)


IF (QCIADDREP.GT.0) THEN
   CALL CONGRAD3(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
!
! Don't do the CONINT part of CONGRAD2 if CONINT isn't set. CONGRAD seems to be
! dong something different at the moment. Focus on CONGRAD2
!
ELSEIF (CHECKCONINT) THEN
   CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
ELSE
   CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
ENDIF
EOLD=ETOTAL
GLAST(1:D)=G(1:D)
XSAVE(1:D)=X(1:D)

IF (ETOTAL/INTIMAGE.LT.COLDFUSIONLIMIT) THEN
   WRITE(*,'(A,2G20.10)') ' intlbfgs> Cold fusion diagnosed - step discarded, energy, limit=', &
  &                       ETOTAL/INTIMAGE,COLDFUSIONLIMIT
   DEALLOCATE(CONI,CONJ,CONDISTREF,REPI,REPJ,NREPI,NREPJ,REPCUT,NREPCUT,CONCUT,CONOFFLIST,CONOFFTRIED)
   DEALLOCATE(TRUEEE, EEETMP, MYGTMP, GTMP, &
  &      DIAG, STP, SEARCHSTEP, GDIF,GLAST, XSAVE, XYZ, GGG, CHECKG, IMGFREEZE, EEE, STEPIMAGE)
   QCIIMAGE=INTIMAGE
   INTIMAGE=INTIMAGESAVE
   CONCUTABS=CONCUTABSSAVE
   CONCUTABS2=CONCUTABSSAVE2
   MAXCONE=MAXCONESAVE
   INTRMSTOL=INTRMSTOLSAVE
   KINT=KINTSAVE
   IF (QCIPERMT) THEN 
      NPERMSIZE(1:3*NATOMS)=NPERMSIZEBACK(1:3*NATOMS)
      PERMGROUP(1:3*NATOMS)=PERMGROUPBACK(1:3*NATOMS)
      NSETS(1:3*NATOMS)=NSETSBACK(1:3*NATOMS)
      NPERMGROUP=NPERMGROUPBACK
      SETS(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)=SETSBACK(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)
   ENDIF
   RETURN
ENDIF

! IF (DEBUG) WRITE(*,'(A6,A20,A20,A9,A9)') 'Iter','Energy per image','RMS Force','Step'

!
! In this block PERMGROUP(NDUMMY+J2-1) counts through the atom indices specified in perm.allow,
! one group at a time.
!
IF (PERMDIST) THEN
   IF (ALLOCATED(STARTGROUP)) DEALLOCATE(STARTGROUP)
   IF (ALLOCATED(ENDGROUP)) DEALLOCATE(ENDGROUP)
   IF (ALLOCATED(GROUPACTIVE)) DEALLOCATE(GROUPACTIVE)
   ALLOCATE(STARTGROUP(NPERMGROUP),ENDGROUP(NPERMGROUP),GROUPACTIVE(NPERMGROUP))
   NDUMMY=1
   DO J1=1,NPERMGROUP
      STARTGROUP(J1)=NDUMMY
      GROUPACTIVE(J1)=.FALSE.
      NDUMMY=NDUMMY+NPERMSIZE(J1)
      ENDGROUP(J1)=NDUMMY-1
   ENDDO
ENDIF

567 CONTINUE

DO ! Main do loop with counter NITERDONE, initially set to one

!
! Are we stuck? 
!
IF (QCIRESET) THEN
!  IF ((SWITCHED.AND.(MOD(NITERDONE-1,QCIRESETINT2).EQ.0)).OR.((.NOT.SWITCHED).AND.(MOD(NITERDONE-1,QCIRESETINT1).EQ.0))) THEN
   IF ((.NOT.SWITCHED).AND.(NITERDONE-NLASTGOODE.GT.QCIRESETINT1)) THEN ! .AND.(NITERDONE-NLASTCHANGE.GT.QCIRESETINT1)) THEN
      IF (DEBUG) CALL INTRWG(NACTIVE,INTIMAGE,XYZ,TURNONORDER,NCONOFF)
      IF (DEBUG) CALL WRITEPROFILE(NITERDONE,EEE,INTIMAGE)

      IF (MAX(CONVERGECONTEST,CONVERGEREPTEST).GT.MAXCONE) MAXCONE=MAXCONE*1.1D0
      IF (MAX(FCONTEST,FREPTEST).GT.INTRMSTOL) INTRMSTOL=INTRMSTOL*1.1D0
      CONCUTABS=CONCUTABS+0.1D0
      WRITE(*,'(A,2G20.10,A,G20.10)') ' intlbfgs> Interpolation seems to be stuck. Converge thresholds are now ',MAXCONE,INTRMSTOL, &
  &                          ' concutabs is ',CONCUTABS
      CONCUTABSINC=.TRUE.
      NCONCUTABSINC=NITERDONE

      NLASTGOODE=NITERDONE
!      LASTGOODE=ETOTAL
   ELSEIF (CONCUTABSINC) THEN
      IF (NITERDONE-NCONCUTABSINC.GT.QCIRESETINT1) THEN ! reset CONCUTABS
         CONCUTABS=CONCUTABSSAVE
         IF (CCABSPHASE2) CONCUTABS=CONCUTABSSAVE2
         CONCUTABSINC=.FALSE.
         WRITE(*,'(A,2G20.10,A,G20.10)') ' intlbfgs> Interpolation is NOT stuck. Converge thresholds are ',MAXCONE,INTRMSTOL, &
  &                          ' concutabs reset to ',CONCUTABS
      ENDIF
   ENDIF
ENDIF

!
! Optional alignment of active atoms in successive images every QCINMDN steps. Allow end minima to translate and rotate.
! We have NACTIVE atoms in TURNONORDER vector.
!
IF (QCINMDT.AND.(MOD(NITERDONE-1,QCINMDN).EQ.0)) THEN
   IF (NACTIVE.GT.10) THEN
      PRINT '(A,I6)','intlbfgs> aligning QCI images with newmindist - NACTIVE=',NACTIVE
      CALL NMDALIGN(XYZ,NACTIVE,TURNONORDER,NITERDONE)
   ENDIF
ENDIF
!
!  Check permutational alignments. Maintain a list of the permutable groups where all
!  members are active. See if we have any new complete groups. MUST update NDUMMY
!  counter to step through permutable atom list.
!
IF ((QCILPERMDIST.OR.QCILPDCON).AND.(MOD(NITERDONE-1,QCIPDINT).EQ.0)) THEN


   CALL DOCHICHECK(NEIGHBOUR_COORDS,CENTRE_COORDS,XYZ,NUM_CHIRAL_CENTRES)

   NDUMMY=1
   DO J1=1,NPERMGROUP

      IF (GROUPACTIVE(J1)) GOTO 975
      DO J2=1,NPERMSIZE(J1)
         IF (.NOT.ATOMACTIVE(PERMGROUP(NDUMMY+J2-1))) GOTO 975
      ENDDO
      GROUPACTIVE(J1)=.TRUE.
      IF (DEBUG) WRITE(*,'(A,I6,A)') ' intlbfgs> All permutable atoms in group ',J1,' are active'
975   NDUMMY=NDUMMY+NPERMSIZE(J1)
   ENDDO 

   SAVELOCALPERMCUT=LOCALPERMCUT
   LOCALPERMCUT=QCIPERMCUT ! 

   NPSTART=1
   np: DO J1=1,NPERMGROUP
      IF (.NOT.GROUPACTIVE(J1)) THEN
         NPSTART=NPSTART+NPERMSIZE(J1)
         CYCLE np
      ENDIF

      DO J3=1,INTIMAGE 

!
! Test alignment with previous image
!
!        coordinates for intervening image J3-1, which is image J3 including starting endpoint
         COORDSB(1:3*NATOMS)=XYZ(3*NATOMS*(J3-1)+1:3*NATOMS*J3)
!        coordinates for intervening image J3, which is image J3+1 including starting endpoint
         COORDSA(1:3*NATOMS)=XYZ(3*NATOMS*J3+1:3*NATOMS*(J3+1))
         CALL LOPERMDIST(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,BULKT,TWOD,DISTANCEP,DIST2,.FALSE.,RMATBEST,J1,NMOVEP,PERMP)
         IF (NMOVEP.GT.0)  PRINT '(A,I6,A,2I6,A,I6,A,2G20.10)','intlbfgs> group ',J1,' alignment of images ',J3+1,J3,' moves=',&
  &            NMOVEP, ' permutations, distance with/without permutations=',PDISTANCE,NOPDISTANCE     

         IF ((NMOVEP.GT.0).AND.PBETTER) THEN ! .AND.(ABS(PDISTANCE-NOPDISTANCE).GT.CONCUTABS)) THEN
            COORDSA(1:3*NATOMS)=XYZ(3*NATOMS*J3+1:3*NATOMS*(J3+1))
            DO J4=1,NPERMSIZE(J1)
               J2=PERMGROUP(NPSTART+J4-1)
               IF (PERMP(J2).NE.J2) THEN
                  WRITE(*,'(A,I6,A,I6,A,I6)') ' intlbfgs> image ',J3+1,' move atom ',PERMP(J2),' to position ',J2
                  COORDSA(3*(J2-1)+1)=XYZ(3*NATOMS*J3+3*(PERMP(J2)-1)+1)
                  COORDSA(3*(J2-1)+2)=XYZ(3*NATOMS*J3+3*(PERMP(J2)-1)+2)
                  COORDSA(3*(J2-1)+3)=XYZ(3*NATOMS*J3+3*(PERMP(J2)-1)+3)
!                 NLASTCHANGE=NITERDONE
               ENDIF
            ENDDO
            XYZ(3*NATOMS*J3+1:3*NATOMS*(J3+1))=COORDSA(1:3*NATOMS)
         ENDIF


       ENDDO

      DO J3=INTIMAGE,1,-1 ! reverse order now
!
! Test alignment with next image
!
!        coordinates for intervening image J3+1, which is image J3+2 including starting endpoint
         COORDSB(1:3*NATOMS)=XYZ(3*NATOMS*(J3+1)+1:3*NATOMS*(J3+2))
!        coordinates for intervening image J3, which is image J3+1 including starting endpoint
         COORDSA(1:3*NATOMS)=XYZ(3*NATOMS*J3+1:3*NATOMS*(J3+1))
         CALL LOPERMDIST(COORDSB,COORDSA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,BULKT,TWOD,DISTANCEP,DIST2,.FALSE.,RMATBEST,J1,&
  &          NMOVEP,PERMP)
         IF (NMOVEP.GT.0)  PRINT '(A,I6,A,2I6,A,I6,A,2G20.10)','intlbfgs> group ',J1,' alignment of images ',J3+1,J3+2,' moves=',&
  &          NMOVEP, ' permutations, distance with/without permutations=',PDISTANCE,NOPDISTANCE     

         IF ((NMOVEP.GT.0).AND.PBETTER) THEN ! .AND.(ABS(PDISTANCE-NOPDISTANCE).GT.CONCUTABS)) THEN
            COORDSA(1:3*NATOMS)=XYZ(3*NATOMS*J3+1:3*NATOMS*(J3+1))
            DO J4=1,NPERMSIZE(J1)
               J2=PERMGROUP(NPSTART+J4-1)
               IF (PERMP(J2).NE.J2) THEN
                  WRITE(*,'(A,I6,A,I6,A,I6)') ' intlbfgs> image ',J3+1,' move atom ',PERMP(J2),' to position ',J2
                  COORDSA(3*(J2-1)+1)=XYZ(3*NATOMS*J3+3*(PERMP(J2)-1)+1)
                  COORDSA(3*(J2-1)+2)=XYZ(3*NATOMS*J3+3*(PERMP(J2)-1)+2)
                  COORDSA(3*(J2-1)+3)=XYZ(3*NATOMS*J3+3*(PERMP(J2)-1)+3)
!                 NLASTCHANGE=NITERDONE
               ENDIF
            ENDDO
            XYZ(3*NATOMS*J3+1:3*NATOMS*(J3+1))=COORDSA(1:3*NATOMS)
         ENDIF
       ENDDO

       NPSTART=NPSTART+NPERMSIZE(J1)
    ENDDO np
    LOCALPERMCUT=SAVELOCALPERMCUT

ENDIF

!
!  Dynamic adjustment of KINT values. Local values are changed by QCIKADJUSTFRAC if the
!  corresponding separation is outside a fraction QCIKADJUSTTOL of the average value.
!  The adjustment is done every QCIKADJUSTFRQ cycles.
!  Based on the DNEB adjustment.
!
IF (QCIKADJUSTFRQ.GT.0) THEN
   IF (MOD(NITERDONE,QCIKADJUSTFRQ).EQ.0) THEN ! dynamic adjustment of KINT
      IF (QCIAVDEV.GT.QCIKADJUSTTOL) THEN
         KINT=MIN(KINT*QCIKADJUSTFRAC,QCIKINTMAX)
         IF (DEBUG) PRINT '(2(A,G20.10))',' intlbfgs> Mean deviation ',QCIAVDEV,' Increasing QCI force constant to ',KINT
      ELSEIF (QCIAVDEV.LT.QCIKADJUSTTOL) THEN
         KINT=MAX(KINT/QCIKADJUSTFRAC,QCIKINTMIN)
         IF (DEBUG) PRINT '(2(A,G20.10))',' intlbfgs> Mean deviation ',QCIAVDEV,' Decreasing QCI force constant to ',KINT  
      ENDIF
   ENDIF
ENDIF


!
!  Add next atom to active set if ADDATOM is true. 
!  Constraints to atoms already in the active set are turned on
!  and short-range repulsions to active atoms that are not distance constrained are turned on.
!  *** OLD Find nearest atom to active set attached by a constraint
!  *** NEW Find atom with most constraints to active set
!  Turn on constraint terms for this atom with all previous members of the active set
!  Add repulsions to non-constrained atoms in this set
!  NTOADD is the number of atoms to add to the active set in each pass. 1 seems best!
!
   IF (ADDATOM.AND.((NACTIVE.LT.NATOMS).OR.(NCONOFF.GT.0))) THEN


      IF (NCONOFF.GT.0) THEN
         CONACTIVE(CONOFFLIST(NCONOFF))=.TRUE.
         WRITE(*,'(2(A,I6))') ' intlbfgs> Turn back on constraint ',CONOFFLIST(NCONOFF),' total off=',NCONOFF-1
         NCONOFF=NCONOFF-1
      ELSE

         CALL DOADDATOM(NCONSTRAINT,NEWATOM,IMGFREEZE,INTIMAGE,XYZ,EEE,GGG,TURNONORDER,NITERDONE,NACTIVE,AABACK,BACKDONE,INLIST)  

      ENDIF
      NLASTGOODE=NITERDONE
!      LASTGOODE=ETOTAL
   ENDIF
   GTMP(1:D)=0.0D0
   CALL MAKESTEP(NITERUSE,POINT,DIAG,INTIMAGE,SEARCHSTEP,G,GTMP,STP,GDIF,NPT,D,RHO1,ALPHA)
!
! If the number of images has changed since G was declared then G is not the same
! size as Gtmp and Dot_Product cannot be used.
!
!  IF (Dot_Product(G,Gtmp)/SQRT( Dot_Product(G,G)*Dot_Product(Gtmp,Gtmp) ) > 0.0D0) THEN
!
!  Separate sqrt;s to avoid overflow.
!
   IF (DDOT(D,G,1,GTMP,1)/MAX(1.0D-100,SQRT( DDOT(D,G,1,G,1))*SQRT(DDOT(D,GTMP,1,GTMP,1)) ) > 0.0D0) THEN
        IF (DEBUG) WRITE(*,*) 'Search direction has positive projection onto gradient - reversing step'
        GTMP(1:D)=-GTMP(1:D)
        SEARCHSTEP(POINT,1:D)=GTMP(1:D)
   ENDIF
   GTMP(1:D)=G(1:D)

!  We should apply the maximum LBFGS step to each image separately.
!  However, using different scale factors for different images leads to huge
!  discontinuities! Now take the minimum scale factor for all images. DJW 26/11/07

   STPMIN=1.0D0
   DO J2=1,INTIMAGE
      STEPIMAGE(J2) = SQRT(DOT_PRODUCT(SEARCHSTEP(POINT,(3*NATOMS)*(J2-1)+1:(3*NATOMS)*J2), &
  &                                    SEARCHSTEP(POINT,(3*NATOMS)*(J2-1)+1:(3*NATOMS)*J2)))
      DUMMY=STEPIMAGE(J2)
      IF (STEPIMAGE(J2) > MAXINTBFGS) THEN
           STP((3*NATOMS)*(J2-1)+1:(3*NATOMS)*J2) = MAXINTBFGS/STEPIMAGE(J2)
           STPMIN=MIN(STPMIN,STP((3*NATOMS)*(J2-1)+1))
      ENDIF
!     WRITE(*,'(A,I8,3G20.10)') ' image,initial step size,STP,prod=',J2,DUMMY,STP(3*NATOMS*(J2-1)+1), &
! &                                   STEPIMAGE(J2)*STP(3*NATOMS*(J2-1)+1)   
   ENDDO
   STP(1:D)=STPMIN
! EFK: decide whether to freeze some nodes
   IF (FREEZENODEST) THEN
      TOTGNORM=SQRT(DOT_PRODUCT(G(1:(3*NATOMS)*INTIMAGE),G(1:(3*NATOMS)*INTIMAGE))/INTIMAGE)
      NIMAGEFREEZE=0
      DO IM=1,INTIMAGE
         TESTG=SQRT(DOT_PRODUCT(G((3*NATOMS)*(IM-1)+1:(3*NATOMS)*IM),G((3*NATOMS)*(IM-1)+1:(3*NATOMS)*IM)))
         IMGFREEZE(IM)=.FALSE.
         IF (TOTGNORM.NE.0.0D0) THEN
!           IF (TESTG/TOTGNORM.LT.FREEZETOL) THEN
            IF (TESTG/SQRT(3.0D0*NATOMS).LT.FREEZETOL) THEN
!              IF (DEBUG) PRINT '(A,I6,3G20.10)', ' intlbfgs> Freezing image: ',IM,TESTG,FREEZETOL,TOTGNORM
               IMGFREEZE(IM)=.TRUE.
               STEPIMAGE(IM)=0.0D0
               NIMAGEFREEZE=NIMAGEFREEZE+1
               STP((3*NATOMS)*(IM-1)+1:(3*NATOMS)*IM)=0.0D0
            ENDIF
         ENDIF
      ENDDO
      IF (DEBUG) PRINT '(2(A,I6))', ' intlbfgs> Number of frozen images=',NIMAGEFREEZE,' / ',INTIMAGE
   ENDIF
   !  We now have the proposed step - update geometry and calculate new gradient
   NDECREASE=0
20 X(1:D) = X(1:D) + STP(1:D)*SEARCHSTEP(POINT,1:D)

!  IF (.NOT.SWITCHED) THEN
   IF (.TRUE.) THEN

      IF (REMOVEIMAGE.OR.(MOD(NITERDONE,INTIMAGECHECK).EQ.0)) THEN
864      CONTINUE ! for adding more than one image at a time
         DMAX=-1.0D0
         ADMAX=-1.0D0
         DMIN=HUGE(1.0D0)
         DO J1=1,INTIMAGE+1
            DUMMY=0.0D0

            DO J2=1,NATOMS
               IF (ATOMACTIVE(J2)) THEN
                  ADUMMY=( XYZ((J1-1)*3*NATOMS+3*(J2-1)+1) - XYZ(J1*3*NATOMS+3*(J2-1)+1) )**2 &
  &                     +( XYZ((J1-1)*3*NATOMS+3*(J2-1)+2) - XYZ(J1*3*NATOMS+3*(J2-1)+2) )**2 &
  &                     +( XYZ((J1-1)*3*NATOMS+3*(J2-1)+3) - XYZ(J1*3*NATOMS+3*(J2-1)+3) )**2 
                  DUMMY=DUMMY+ADUMMY
                  IF (ADUMMY.GT.ADMAX) THEN
                     ADMAX=ADUMMY
                     JA1=J1
                     JA2=J2
                  ENDIF
               ENDIF
            ENDDO
            DUMMY=SQRT(DUMMY)
            IF (DUMMY.GT.DMAX) THEN
               DMAX=DUMMY
               JMAX=J1
            ENDIF
            IF (DUMMY.LT.DMIN) THEN
               DMIN=DUMMY
               JMIN=J1
            ENDIF

         ENDDO

         IF ((.NOT.REMOVEIMAGE).AND.((SQRT(ADMAX).GT.IMSEPMAX).AND.(INTIMAGE.LT.MAXINTIMAGE))) THEN
            JMAX=JA1
            WRITE(*,'(A,I6,A,I6,A,I6)') ' intlbfgs> Add an image between ',JMAX,' and ',JMAX+1,' INTIMAGE=',INTIMAGE
            NITERUSE=0
            ALLOCATE(DPTMP(3*NATOMS*(INTIMAGE+2)))
            DPTMP(1:3*NATOMS*(INTIMAGE+2))=XYZ(1:3*NATOMS*(INTIMAGE+2))
            DEALLOCATE(XYZ)
            ALLOCATE(XYZ(3*NATOMS*(INTIMAGE+3)))
            XYZ(1:3*NATOMS*JMAX)=DPTMP(1:3*NATOMS*JMAX)
            XYZ(3*NATOMS*JMAX+1:3*NATOMS*(JMAX+1))=(DPTMP(3*NATOMS*(JMAX-1)+1:3*NATOMS*JMAX) &
  &                                               + DPTMP(3*NATOMS*JMAX+1:3*NATOMS*(JMAX+1)))/2.0D0
            XYZ(3*NATOMS*(JMAX+1)+1:3*NATOMS*(INTIMAGE+3))=DPTMP(3*NATOMS*JMAX+1:3*NATOMS*(INTIMAGE+2))
!
! Save step-taking memories in SEARCHSTEP and GDIF.
! These arrays run from 0 to INTMUPDATE over memories and
! 1:(3*NATOMS)*INTIMAGE over only the variable images.
!
            DEALLOCATE(DPTMP)
            ALLOCATE(D2TMP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE))
            D2TMP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)=SEARCHSTEP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)
            DEALLOCATE(SEARCHSTEP)
            ALLOCATE(SEARCHSTEP(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE+1)))
            DO J1=0,INTMUPDATE
               IF (JMAX.GT.1) SEARCHSTEP(J1,1:3*NATOMS*(JMAX-1))=D2TMP(J1,1:3*NATOMS*(JMAX-1))
               IF (JMAX.LT.INTIMAGE+1) SEARCHSTEP(J1,3*NATOMS*JMAX+1:3*NATOMS*(INTIMAGE+1))= &
  &                 D2TMP(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*INTIMAGE)
               SEARCHSTEP(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*JMAX)= &
  &                             D2TMP(J1,3*NATOMS*(MIN(JMAX,INTIMAGE)-1)+1:3*NATOMS*MIN(JMAX,INTIMAGE))
            ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            SEARCHSTEP(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE+1))=0.0D0
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            D2TMP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)=GDIF(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)
            DEALLOCATE(GDIF)
            ALLOCATE(GDIF(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE+1)))
            DO J1=0,INTMUPDATE
               IF (JMAX.GT.1) GDIF(J1,1:3*NATOMS*(JMAX-1))=D2TMP(J1,1:3*NATOMS*(JMAX-1))
               IF (JMAX.LT.INTIMAGE+1) GDIF(J1,3*NATOMS*JMAX+1:3*NATOMS*(INTIMAGE+1))= &
  &                 D2TMP(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*INTIMAGE)
               GDIF(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*JMAX)= &
  &                       D2TMP(J1,3*NATOMS*(MIN(JMAX,INTIMAGE)-1)+1:3*NATOMS*MIN(JMAX,INTIMAGE))
            ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            GDIF(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE+1))=0.0D0
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            DEALLOCATE(D2TMP)

            DEALLOCATE(TRUEEE,EEETMP,MYGTMP,GTMP,GGG, &
  &                    DIAG,STP,GLAST,XSAVE,EEE,STEPIMAGE,CHECKG,IMGFREEZE)
            ALLOCATE(TRUEEE(INTIMAGE+3), &
  &                  EEETMP(INTIMAGE+3), MYGTMP(3*NATOMS*(INTIMAGE+1)), &
  &                  GTMP(3*NATOMS*(INTIMAGE+1)), &
  &                  DIAG(3*NATOMS*(INTIMAGE+1)), STP(3*NATOMS*(INTIMAGE+1)), &
  &                  GLAST((3*NATOMS)*(INTIMAGE+1)), &
  &                  XSAVE((3*NATOMS)*(INTIMAGE+1)), CHECKG((3*NATOMS)*(INTIMAGE+1)), IMGFREEZE(INTIMAGE+1), &
  &                  EEE(INTIMAGE+3), STEPIMAGE(INTIMAGE+1), GGG(3*NATOMS*(INTIMAGE+3)))
            GGG(1:3*NATOMS*(INTIMAGE+3))=0.0D0
            TRUEEE(1:INTIMAGE+3)=0.0D0
            EEETMP(1:INTIMAGE+3)=0.0D0
            MYGTMP(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            GTMP(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            DIAG(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            STP(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            GLAST(1:(3*NATOMS)*(INTIMAGE+1))=0.0D0
            XSAVE(1:(3*NATOMS)*(INTIMAGE+1))=0.0D0
            CHECKG(1:(3*NATOMS)*(INTIMAGE+1))=.FALSE.
            IMGFREEZE(1:INTIMAGE+1)=.FALSE.
            EEE(1:INTIMAGE+3)=0.0D0
            STEPIMAGE(1:INTIMAGE+1)=0.0D0

            X=>XYZ((3*NATOMS)+1:(3*NATOMS)*(INTIMAGE+2))
            G=>GGG((3*NATOMS)+1:(3*NATOMS)*(INTIMAGE+2))
            INTIMAGE=INTIMAGE+1
            D=(3*NATOMS)*INTIMAGE
            CALL CHECKREP(INTIMAGE,XYZ,(3*NATOMS),0,1)
            IF (QCIADDREP.GT.0) THEN
               CALL CONGRAD3(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSEIF (CHECKCONINT) THEN
               CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSE
               CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ENDIF
!           GOTO 864
         ENDIF
         IF (REMOVEIMAGE.OR.((DMIN.LT.IMSEPMIN).AND.(INTIMAGE.GT.1))) THEN
            IF (REMOVEIMAGE) JMIN=JMAXEEE
            IF (JMIN.EQ.1) JMIN=2
            WRITE(*,'(A,I6,A,I6)') ' intlbfgs> Remove image ',JMIN
            NITERUSE=0
            ALLOCATE(DPTMP(3*NATOMS*(INTIMAGE+2)))
            DPTMP(1:3*NATOMS*(INTIMAGE+2))=XYZ(1:3*NATOMS*(INTIMAGE+2))
            DEALLOCATE(XYZ)
            ALLOCATE(XYZ(3*NATOMS*(INTIMAGE+1)))
            XYZ(1:3*NATOMS*(JMIN-1))=DPTMP(1:3*NATOMS*(JMIN-1))
            XYZ(3*NATOMS*(JMIN-1)+1:3*NATOMS*(INTIMAGE+1))=DPTMP(3*NATOMS*JMIN+1:3*NATOMS*(INTIMAGE+2))

            DEALLOCATE(DPTMP)
!
! Save step-taking memories in SEARCHSTEP and GDIF.
! These arrays run from 0 to INTMUPDATE over memories and
! 1:(3*NATOMS)*INTIMAGE over only the variable images.
!
            ALLOCATE(D2TMP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE))
            D2TMP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)=SEARCHSTEP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)
            DEALLOCATE(SEARCHSTEP)
            ALLOCATE(SEARCHSTEP(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE-1)))
            DO J1=0,INTMUPDATE
               SEARCHSTEP(J1,1:3*NATOMS*(JMIN-2))=D2TMP(J1,1:3*NATOMS*(JMIN-2))
               SEARCHSTEP(J1,3*NATOMS*(JMIN-2)+1:3*NATOMS*(INTIMAGE-1))= &
  &                     D2TMP(J1,3*NATOMS*(JMIN-1)+1:3*NATOMS*INTIMAGE)
            ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            SEARCHSTEP(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE-1))=0.0D0
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            D2TMP(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)=GDIF(0:INTMUPDATE,1:(3*NATOMS)*INTIMAGE)
            DEALLOCATE(GDIF)
            ALLOCATE(GDIF(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE-1)))
            DO J1=0,INTMUPDATE
               GDIF(J1,1:3*NATOMS*(JMIN-2))=D2TMP(J1,1:3*NATOMS*(JMIN-2))
               GDIF(J1,3*NATOMS*(JMIN-2)+1:3*NATOMS*(INTIMAGE-1))= &
  &                     D2TMP(J1,3*NATOMS*(JMIN-1)+1:3*NATOMS*INTIMAGE)
            ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            GDIF(0:INTMUPDATE,1:(3*NATOMS)*(INTIMAGE-1))=0.0D0
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            DEALLOCATE(D2TMP)

            DEALLOCATE(TRUEEE,EEETMP,MYGTMP,GTMP,GGG, &
  &                    DIAG,STP,GLAST,XSAVE,EEE,STEPIMAGE,CHECKG,IMGFREEZE)
            ALLOCATE(TRUEEE(INTIMAGE+1),&
  &                  EEETMP(INTIMAGE+1), MYGTMP(3*NATOMS*(INTIMAGE-1)), &
  &                  GTMP(3*NATOMS*(INTIMAGE-1)), &
  &                  DIAG(3*NATOMS*(INTIMAGE-1)), STP(3*NATOMS*(INTIMAGE-1)), &
  &                  GLAST((3*NATOMS)*(INTIMAGE-1)), &
  &                  XSAVE((3*NATOMS)*(INTIMAGE-1)), CHECKG((3*NATOMS)*(INTIMAGE-1)), IMGFREEZE(INTIMAGE-1), &
  &                  EEE(INTIMAGE+1), STEPIMAGE(INTIMAGE-1), GGG(3*NATOMS*(INTIMAGE+1)))
            GGG(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            TRUEEE(1:INTIMAGE+1)=0.0D0
            EEETMP(1:INTIMAGE+1)=0.0D0
            MYGTMP(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            GTMP(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            DIAG(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            STP(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            GLAST(1:(3*NATOMS)*(INTIMAGE-1))=0.0D0
            XSAVE(1:(3*NATOMS)*(INTIMAGE-1))=0.0D0
            CHECKG(1:(3*NATOMS)*(INTIMAGE-1))=.FALSE.
            IMGFREEZE(1:INTIMAGE-1)=.FALSE.
            EEE(1:INTIMAGE+1)=0.0D0
            STEPIMAGE(1:INTIMAGE-1)=0.0D0

            X=>XYZ((3*NATOMS)+1:(3*NATOMS)*(INTIMAGE))
            G=>GGG((3*NATOMS)+1:(3*NATOMS)*(INTIMAGE))
            INTIMAGE=INTIMAGE-1
            D=(3*NATOMS)*INTIMAGE
            CALL CHECKREP(INTIMAGE,XYZ,(3*NATOMS),0,1)
            IF (QCIADDREP.GT.0) THEN
               CALL CONGRAD3(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSEIF (CHECKCONINT) THEN
               CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSE
               CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ENDIF
            NLASTGOODE=NITERDONE
!            LASTGOODE=ETOTAL
!           GOTO 864
         ENDIF
      ELSE
         DMAX=-1.0D0
         ADMAX=-1.0D0
         DMIN=HUGE(1.0D0)
         DUMMY2=0.0D0
         DO J1=1,INTIMAGE+1
            DUMMY=0.0D0

            DO J2=1,NATOMS
               IF (ATOMACTIVE(J2)) THEN
                  ADUMMY=( XYZ((J1-1)*3*NATOMS+3*(J2-1)+1) - XYZ(J1*3*NATOMS+3*(J2-1)+1) )**2 &
  &                     +( XYZ((J1-1)*3*NATOMS+3*(J2-1)+2) - XYZ(J1*3*NATOMS+3*(J2-1)+2) )**2 &
  &                     +( XYZ((J1-1)*3*NATOMS+3*(J2-1)+3) - XYZ(J1*3*NATOMS+3*(J2-1)+3) )**2 
                  DUMMY=DUMMY+ADUMMY
                  IF (ADUMMY.GT.ADMAX) THEN
                     ADMAX=ADUMMY
                     JA1=J1
                     JA2=J2
                  ENDIF
               ENDIF
            ENDDO
            
            DUMMY=SQRT(DUMMY)
            DUMMY2=DUMMY2+DUMMY
            IF (DUMMY.GT.DMAX) THEN
               DMAX=DUMMY
               JMAX=J1
            ENDIF
            IF (DUMMY.LT.DMIN) THEN
               DMIN=DUMMY
               JMIN=J1
            ENDIF

         ENDDO
         IF (DEBUG) WRITE(*,'(A,G20.10,A,I6,A,2I6,A,I6)')' intlbfgs> largest atomic distance between images is ', &
  &                                                  SQRT(ADMAX),' for atom ',JA2,' and images ',JA1,JA1+1,' total images=',INTIMAGE

      ENDIF
   ENDIF
!
! End of add/subtract images block.
!
   IF (.NOT.SWITCHED) THEN
      IF (MOD(NITERDONE,CHECKREPINTERVAL).EQ.0) CALL CHECKREP(INTIMAGE,XYZ,(3*NATOMS),0,1)
      IF (QCIADDREP.GT.0) THEN
         CALL CONGRAD3(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ELSEIF (CHECKCONINT) THEN
         CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ELSE
         CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ENDIF

      IF ((ETOTAL-EOLD.LT.1.0D100).OR.ADDATOM) THEN ! MAXERISE effectively set to 1.0D100 here
         EOLD=ETOTAL
         GLAST(1:D)=G(1:D)
         XSAVE(1:D)=X(1:D)
      ELSE
         NDECREASE=NDECREASE+1
         IF (NDECREASE.GT.5) THEN
            NFAIL=NFAIL+1
            WRITE(*,'(A,I6)') ' intlbfgs> WARNING *** in lbfgs cannot find a lower energy, NFAIL=',NFAIL
            X(1:D)=XSAVE(1:D)
            G(1:D)=GLAST(1:D)
         ELSE
            X(1:D)=XSAVE(1:D)
            G(1:D)=GLAST(1:D)
            STP(1:D)=STP(1:D)/10.0D0
            WRITE(*,'(A,G25.15,A,G25.15,A)') ' intlbfgs> energy increased from ',EOLD,' to ',ETOTAL, &
     &          ' decreasing step size'
            GOTO 20
         ENDIF
      ENDIF
      ADDATOM=.FALSE.
   ELSE ! combine constraint and true potentials
      IF (MOD(NITERDONE,CHECKREPINTERVAL).EQ.0) CALL CHECKREP(INTIMAGE,XYZ,(3*NATOMS),0,1)
      ETOTALTMP=0.0D0
      IF (INTCONFRAC.NE.0.0D0) THEN
         DO J4=2,INTIMAGE+1
            IF (CHRMMT) CALL UPDATENBONDS(XYZ((3*NATOMS)*(J4-1)+1:(3*NATOMS)*J4))
            CALL POTENTIAL(XYZ((3*NATOMS)*(J4-1)+1:(3*NATOMS)*J4),EEE(J4),GGG((3*NATOMS)*(J4-1)+1:(3*NATOMS)*J4), &
  &                                    .TRUE.,.FALSE.,RMS,.TRUE.,.FALSE.)
            ETOTALTMP=ETOTALTMP+EEE(J4)
         ENDDO
      ENDIF
      EEETMP(1:INTIMAGE+2)=EEE(1:INTIMAGE+2)
      MYGTMP(1:D)=G(1:D)
      IF (USEFRAC.LT.1.0D0) THEN
         IF (QCIADDREP.GT.0) THEN
            CALL CONGRAD3(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSEIF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
      ELSE
         ETOTAL=0.0D0
         G(1:D)=0.0D0
      ENDIF
      ETOTAL=USEFRAC*ETOTALTMP+(1.0D0-USEFRAC)*ETOTAL
      G(1:D)=USEFRAC*MYGTMP(1:D)+(1.0D0-USEFRAC)*G(1:D)
      RMS=SUM(G(1:D)**2)
      RMS=SQRT(RMS/((3*NATOMS)*INTIMAGE))
      EEE(1:INTIMAGE+2)=USEFRAC*EEETMP(1:INTIMAGE+2)+(1.0D0-USEFRAC)*EEE(1:INTIMAGE+2)
      WORST=-1.0D100
      DO J4=2,INTIMAGE+1
         IF (EEE(J4).GT.WORST) WORST=EEE(J4)
      ENDDO
      IF (DEBUG) WRITE(*,'(A,G20.10,A,I8)') ' intlbfgs> Highest QCI image energy=',WORST,' images=',INTIMAGE
   ENDIF
   IF (ETOTAL/INTIMAGE.LT.COLDFUSIONLIMIT) THEN
      WRITE(*,'(A,2G20.10)') ' intlbfgs> Cold fusion diagnosed - step discarded, energy, limit=',ETOTAL/INTIMAGE,COLDFUSIONLIMIT
      DEALLOCATE(CONI,CONJ,CONDISTREF,REPI,REPJ,NREPI,NREPJ,REPCUT,NREPCUT,CONCUT,CONOFFLIST,CONOFFTRIED)
      DEALLOCATE(TRUEEE, EEETMP, MYGTMP, GTMP, &
  &              DIAG, STP, SEARCHSTEP, GDIF,GLAST, XSAVE, XYZ, GGG, CHECKG, IMGFREEZE, EEE, STEPIMAGE)
      QCIIMAGE=INTIMAGE
      INTIMAGE=INTIMAGESAVE
      CONCUTABS=CONCUTABSSAVE
      CONCUTABS2=CONCUTABSSAVE2
      MAXCONE=MAXCONESAVE
      INTRMSTOL=INTRMSTOLSAVE
      KINT=KINTSAVE
      IF (QCIPERMT) THEN 
         NPERMSIZE(1:3*NATOMS)=NPERMSIZEBACK(1:3*NATOMS)
         PERMGROUP(1:3*NATOMS)=PERMGROUPBACK(1:3*NATOMS)
         NSETS(1:3*NATOMS)=NSETSBACK(1:3*NATOMS)
         NPERMGROUP=NPERMGROUPBACK
         SETS(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)=SETSBACK(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)
      ENDIF
      RETURN
   ENDIF

   STEPTOT = SUM(STEPIMAGE)/INTIMAGE

   MAXRMS=-1.0D0
   MAXEEE=-1.0D100
   MINEEE=1.0D100
   SUMEEE=0.0D0
   SUMEEE2=0.0D0
   DO J1=2,INTIMAGE+1
      SUMEEE=SUMEEE+EEE(J1)
      SUMEEE2=SUMEEE2+EEE(J1)**2
      IF (EEE(J1).GT.MAXEEE) THEN
         MAXEEE=EEE(J1)
         JMAXEEE=J1
      ENDIF
      IF (EEE(J1).LT.MINEEE) THEN
         MINEEE=EEE(J1)
      ENDIF
      DUMMY=0.0D0
      DO J2=1,3*NATOMS
         DUMMY=DUMMY+GGG(3*NATOMS*(J1-1)+J2)**2
      ENDDO
      IF (DUMMY.GT.MAXRMS) THEN
         MAXRMS=DUMMY
      ENDIF
   ENDDO
   MAXRMS=SQRT(MAXRMS/(3*NACTIVE))
   SUMEEE=SUMEEE/INTIMAGE
   SUMEEE2=SUMEEE2+EEE(J1)**2
   SUMEEE2=SUMEEE2/INTIMAGE
   SIGMAEEE=SQRT(MAX(SUMEEE2-SUMEEE**2,1.0D-300))
   REMOVEIMAGE=.FALSE.

      IF (SIGMAEEE.GT.0.0D0) THEN
         If (DEBUG) WRITE(*,'(A,I8,A,G20.10,A,G20.10,A)') ' intlbfgs> Highest image ',JMAXEEE,' energy ',MAXEEE,' is ',&
  &        ABS(MAXEEE-SUMEEE)/SIGMAEEE,  ' sigma from the mean'
      ENDIF


   IF (DEBUG) THEN

!
! CONVERGECONTEST and CONVERGEREPTEST are the largest single constraint and repulsion terms for any constraint and repulsion contribution
! FCONTEST and FREPTEST are the maximum components in the gradient vector for constraint and repulsion terms
! STEPTOT avergage step size per image
!
! Scale the values by the prefactors, so we don't need to change them when we change the con/rep balance
!
      CONVERGECONTEST=CONVERGECONTEST/INTCONSTRAINTDEL
      CONVERGEREPTEST=CONVERGEREPTEST/INTCONSTRAINTREP
      FCONTEST=FCONTEST/INTCONSTRAINTDEL
      FREPTEST=FREPTEST/INTCONSTRAINTREP
      WRITE(*,'(A,I6,5G20.10,I10,I6)') ' intlbfgs> steps: ',NITERDONE,CONVERGECONTEST, &
  &             CONVERGEREPTEST,FCONTEST,FREPTEST,STEPTOT,NACTIVE,INTIMAGE+2
      CALL FLUSH(6)
   ENDIF

   IF (.NOT.SWITCHED) THEN
!     IF ((NITERDONE-NLASTGOODE.GT.INTRELSTEPS).AND.((ETOTAL.GT.LASTGOODE).OR.(ETOTAL/INTIMAGE.GT.MAXCONE*1.0D8))) THEN
      IF (.FALSE.) THEN ! no backtracking
         WRITE(*,'(2(A,I6))') ' intlbfgs> Backtracking ',NBACKTRACK,' steps, current active atoms=',NACTIVE
         NTRIES(NEWATOM)=NTRIES(NEWATOM)+1
         IF (FREEZENODEST) IMGFREEZE(1:INTIMAGE)=.FALSE.
!
! Backtrack by removing the last NBACKTRACK atoms along with their active constraints and
! repulsions.
!
         NOFF=0
         DO J1=1,NBACKTRACK
            NDUMMY=TURNONORDER(NACTIVE-J1+1)
            IF (INTFROZEN(NDUMMY)) THEN
               IF (DEBUG) WRITE(*,'(A,I6,A,2I6)') ' intlbfgs> Not turning off frozen active atom ',NDUMMY
               CYCLE
            ENDIF
            IF (DEBUG) WRITE(*,'(A,I6,A,2I6)') ' intlbfgs> Turning off active atom ',NDUMMY
            DO J2=1,NCONSTRAINT
               IF (.NOT.CONACTIVE(J2)) CYCLE 
               IF ((CONI(J2).EQ.NDUMMY).OR.(CONJ(J2).EQ.NDUMMY)) THEN
                  CONACTIVE(J2)=.FALSE.
                  IF (DEBUG) WRITE(*,'(A,I6,A,2I6)') ' intlbfgs> Turning off constraint ',J2,' for atoms ',CONI(J2),CONJ(J2)
               ENDIF
            ENDDO
            ATOMACTIVE(NDUMMY)=.FALSE.
            NOFF=NOFF+1
         ENDDO
         NACTIVE=NACTIVE-NOFF
         NDUMMY=1
         NREPULSIVE=0
         DO J1=1,NATOMS
! 
! Make a list of repelling atoms here and then use it
! CONI(J2) is always less than CONJ(J2) so we only need to
! cycle over a given range of constraints and continue from
! where we left off for the next atom j1
!  
            ADDREP(1:J1+INTREPSEP)=.FALSE.
            ADDREP(J1+INTREPSEP+1:NATOMS)=.TRUE. ! no repulsion for atoms too close in sequence
            IF (INTFROZEN(J1)) THEN
               DO J2=J1+INTREPSEP+1,NATOMS
                  IF (INTFROZEN(J2)) ADDREP(J2)=.FALSE.
               ENDDO
            ENDIF
            addloop: DO J2=NDUMMY,NCONSTRAINT
               IF (CONI(J2).EQ.J1) THEN
                  ADDREP(CONJ(J2))=.FALSE.
               ELSE
                  NDUMMY=J2 ! for next atom
                  EXIT addloop
               ENDIF
            ENDDO addloop
            rep2: DO J2=J1+INTREPSEP+1,NATOMS

               IF (.NOT.ADDREP(J2)) CYCLE
!
! Don't we need to check atomactive here for backtracking?
!
!              IF (.NOT.ATOMACTIVE(J2)) CYCLE 

               DMIN=1.0D100
               DO J3=1,INTIMAGE+2,INTIMAGE+1 ! only consider the end-point distances
                  DF=SQRT((XYZ((J3-1)*3*NATOMS+3*(J2-1)+1)-XYZ((J3-1)*3*NATOMS+3*(J1-1)+1))**2+ &
    &                     (XYZ((J3-1)*3*NATOMS+3*(J2-1)+2)-XYZ((J3-1)*3*NATOMS+3*(J1-1)+2))**2+ &
    &                     (XYZ((J3-1)*3*NATOMS+3*(J2-1)+3)-XYZ((J3-1)*3*NATOMS+3*(J1-1)+3))**2)
                  IF (DF.LT.DMIN) DMIN=DF
               ENDDO

               NREPULSIVE=NREPULSIVE+1
               IF (NREPULSIVE.GT.NREPMAX) CALL REPDOUBLE
               REPI(NREPULSIVE)=J1
               REPJ(NREPULSIVE)=J2
! 
! Use the minimum of the end point distances and INTCONSTRAINREPCUT for each contact.
!
               REPCUT(NREPULSIVE)=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
            ENDDO rep2
         ENDDO


         NBACKTRACK=MAX(MIN(MIN(1.0D0*(NBACKTRACK+1),1.0D0*50),1.0D0*(NACTIVE-2-NQCIFREEZE)),1.0D0)
!        IF (DEBUG) WRITE(*,'(A,I6)') ' intlbfgs> Number of atoms to backtrack is now ',NBACKTRACK
         NDUMMY=0
         DO J1=1,NATOMS
            IF (ATOMACTIVE(J1)) NDUMMY=NDUMMY+1
         ENDDO
         IF (NDUMMY.NE.NACTIVE) THEN
            WRITE(*,'(A,I6)') ' intlbfgs> ERROR *** inconsistency in number of active atoms. ',NDUMMY,' should be ',NACTIVE
            DO J1=1,NATOMS
               IF (ATOMACTIVE(J1)) WRITE(*,'(A,I6)') ' active atom ',J1
            ENDDO
            STOP
         ENDIF
         ADDATOM=.TRUE.

         CALL CHECKREP(INTIMAGE,XYZ,(3*NATOMS),0,1)
         IF (QCIADDREP.GT.0) THEN
            CALL CONGRAD3(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSEIF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
      ENDIF
!      LASTGOODE=ETOTAL
   ENDIF

   EXITSTATUS=0
   INTDGUESS=DIAG(1) ! should be ok for subsequent runs of the same system DJW

   IF ((.NOT.SWITCHED).AND.(FCONTEST.LT.INTRMSTOL).AND.(FREPTEST.LT.INTRMSTOL).AND.(NITERDONE>1) &
  &                   .AND.(CONVERGECONTEST.LT.MAXCONE).AND.(CONVERGEREPTEST.LT.MAXCONE)) EXITSTATUS=1 

   IF (NITERDONE==NSTEPSMAX) EXITSTATUS=2
   IF ((.NOT.SWITCHED).AND.(MOD(NITERDONE,INTRELSTEPS).EQ.0)) EXITSTATUS=1 ! Add an atom every INTRELSTEPS !!! DJW

   IF (EXITSTATUS > 0) THEN  
      IF ((.NOT.SWITCHED).AND.(EXITSTATUS.EQ.1)) THEN ! add active atom or restart with true potential on

         IF (NACTIVE.LT.NATOMS) THEN 
            ADDATOM=.TRUE.
            GOTO 777
         ENDIF
         CALL MYCPU_TIME(FTIME,.FALSE.)
         WRITE(*,'(A,I6,A,F12.6,A,I6,A,G20.10)') ' intlbfgs> switch on true potential at step ',NITERDONE, &
  &                                     ' fraction=',INTCONFRAC,' images=',INTIMAGE,' time=',FTIME-STIME
         CALL INTRWG(NACTIVE,INTIMAGE,XYZ,TURNONORDER,NCONOFF)
         CALL WRITEPROFILE(NITERDONE,EEE,INTIMAGE)
         WRITE(*,'(A,I6,A,F15.6)') ' intlbfgs> Allowing ',INTCONSTEPS,' further optimization steps'
         DO J1=1,NATOMS
            IF (.NOT.ATOMACTIVE(J1)) THEN
               WRITE(*,'(A,I6,A,I6,A)') ' intlbfgs> ERROR *** number of active atoms=',NACTIVE,' but atom ',J1,' is not active'
            ENDIF
         ENDDO
         NSTEPSMAX=NITERDONE+INTCONSTEPS
         SWITCHED=.TRUE.
         RMS=INTRMSTOL*10.0D0 ! to prevent premature convergence
         G(1:(3*NATOMS)*INTIMAGE)=INTRMSTOL*10.0D0
         USEFRAC=INTCONFRAC
         GOTO 777
      ELSEIF ((.NOT.SWITCHED).AND.(EXITSTATUS.EQ.2)) THEN 
         WRITE(*,'(A,I6)') ' intlbfgs> QCI ERROR *** number of active atoms at final step=',NACTIVE
         CALL FLUSH(6)
!
! must not reset here if we are allowing the program to continue. The reset will be done before return.
!

      ELSEIF (SWITCHED.AND.(.NOT.CCABSPHASE2)) THEN 
         CONCUTABS=CONCUTABS2
         CCABSPHASE2=.TRUE.
         WRITE(*,'(A,I6,A,F15.6)') ' intlbfgs> Allowing ',INTCONSTEPS,' further optimization steps'
         WRITE(*,'(A,F12.6)') ' intlbfgs> extra distance before turning on constraint potential is now ',CONCUTABS
         NSTEPSMAX=NITERDONE+INTCONSTEPS
         GOTO 777
      ELSEIF (DEBUG) THEN
         WRITE(*,'(A,I6,A,I6)') ' intlbfgs> energies for images:'
         WRITE(*,'(I6,F20.10)') (J2,EEE(J2),J2=1,INTIMAGE+2)
      ENDIF
      EXIT
   ENDIF
   777 CONTINUE
!
! Compute the new step and gradient change
!
   NPT=POINT*D
   SEARCHSTEP(POINT,:) = STP*SEARCHSTEP(POINT,:)
   GDIF(POINT,:)=G-GTMP
   
   POINT=POINT+1; IF (POINT==INTMUPDATE) POINT=0

   IF (DUMPINTXYZ.AND.MOD(NITERDONE,DUMPINTXYZFREQ)==0) CALL INTRWG(NACTIVE,INTIMAGE,XYZ,TURNONORDER,NCONOFF)
   IF (DUMPINTEOS.AND.MOD(NITERDONE,DUMPINTEOSFREQ)==0) CALL WRITEPROFILE(NITERDONE,EEE,INTIMAGE)
!  IF (NITERDONE.GT.0) CALL INTRWG2(NACTIVE,NITERDONE,INTIMAGE,XYZ,TURNONORDER,NCONOFF) !!! DEBUG DJW

   NITERDONE=NITERDONE+1
   NITERUSE=NITERUSE+1

   IF (NITERDONE.GT.NSTEPSMAX) EXIT
   IF (NACTIVE.EQ.NATOMS) THEN
      IF (.NOT.SWITCHED) THEN
         CALL MYCPU_TIME(FTIME,.FALSE.)
         WRITE(*,'(A,I6,A,F12.6,A,I6,A,F10.1)') ' intlbfgs> switch on true potential at step ',NITERDONE, &
  &                                     ' fraction=',INTCONFRAC,' images=',INTIMAGE,' time=',FTIME-STIME
         WRITE(*,'(A,I6,A,F15.6)') ' intlbfgs> Allowing ',INTCONSTEPS,' further optimization steps'
         DO J1=1,NATOMS
            IF (.NOT.ATOMACTIVE(J1)) THEN
               WRITE(*,'(A,I6,A,I6,A)') ' intlbfgs> ERROR *** number of active atoms=',NACTIVE,' but atom ',J1,' is not active'
            ENDIF
         ENDDO
         NSTEPSMAX=NITERDONE+INTCONSTEPS
         SWITCHED=.TRUE.
         IF (FREEZENODEST) THEN
            IMGFREEZE(1:INTIMAGE)=.FALSE.
         ENDIF
         RMS=INTRMSTOL*10.0D0 ! to prevent premature convergence
         USEFRAC=INTCONFRAC
      ENDIF
   ENDIF

ENDDO ! end of main do loop over counter NITERDONE

      CALL FLUSH(6)

IF (.NOT.SWITCHED) THEN 
   WRITE(*,'(A,I6,A)') ' intlbfgs> QCI DID NOT CONVERGE number of active atoms at final step=',NACTIVE,' no potential switch'
ENDIF
IF (EXITSTATUS.EQ.1) THEN
   WRITE(*,'(A,I6,A,G20.10,A,G15.8,A,I4)') ' intlbfgs> Converged after ',NITERDONE,' steps, energy/image=',ETOTAL/INTIMAGE, &
  &                               ' RMS=',RMS,' images=',INTIMAGE
ELSEIF (EXITSTATUS.EQ.2) THEN
   WRITE(*,'(A,I6,A,G20.10,A,G15.8,A,I4)') ' intlbfgs> After ',NITERDONE,' steps, energy/image=',ETOTAL/INTIMAGE, &
  &                               ' RMS=',RMS,' images=',INTIMAGE
ENDIF
678 CONTINUE

! CALL INTRWG(NACTIVE,NTIMAGE,XYZ,TURNONORDER,NCONOFF)
! CALL WRITEPROFILE(NITERDONE,EEE,INTIMAGE)

IF (DEBUG) WRITE(*,'(A,G20.10)') ' intlbfgs> WORST=',WORST

BESTWORST=WORST
IF (ALLOCATED(QCIXYZ)) DEALLOCATE(QCIXYZ)
ALLOCATE(QCIXYZ(3*NATOMS*(INTIMAGE+2)))
QCIXYZ(1:3*NATOMS*(INTIMAGE+2))=XYZ(1:3*NATOMS*(INTIMAGE+2))
WRITE(*,'(A,I8,A,G20.10)') ' intlbfgs> retaining ',INTIMAGE,' QCI images, highest energy=',BESTWORST

CALL INTRWG(NACTIVE,INTIMAGE,XYZ,TURNONORDER,NCONOFF)
CALL WRITEPROFILE(0,EEE,INTIMAGE)

DEALLOCATE(CONI,CONJ,CONDISTREF,REPI,REPJ,NREPI,NREPJ,REPCUT,NREPCUT,CONCUT,CONOFFLIST,CONOFFTRIED)
DEALLOCATE(TRUEEE, EEETMP, MYGTMP, GTMP, &
  &      DIAG, STP, SEARCHSTEP, GDIF,GLAST, XSAVE, XYZ, GGG, CHECKG, IMGFREEZE, EEE, STEPIMAGE)
IF (ALLOCATED(CONLIST)) DEALLOCATE(CONLIST)
IF (ALLOCATED(NCONATOM)) DEALLOCATE(NCONATOM)
IF (ALLOCATED(COMMONCON)) DEALLOCATE(COMMONCON)

IF (QCISTOP) STOP 

!
! Reset things that may have changed.
!
QCIIMAGE=INTIMAGE
INTIMAGE=INTIMAGESAVE
CONCUTABS=CONCUTABSSAVE
CONCUTABS2=CONCUTABSSAVE2
MAXCONE=MAXCONESAVE
INTRMSTOL=INTRMSTOLSAVE
KINT=KINTSAVE
IF (QCIPERMT) THEN 
   NPERMSIZE(1:3*NATOMS)=NPERMSIZEBACK(1:3*NATOMS)
   PERMGROUP(1:3*NATOMS)=PERMGROUPBACK(1:3*NATOMS)
   NSETS(1:3*NATOMS)=NSETSBACK(1:3*NATOMS)
   NPERMGROUP=NPERMGROUPBACK
   SETS(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)=SETSBACK(1:NATOMS,1:NPERMGROUP,1:MAXNSETS)
ENDIF

END SUBROUTINE INTLBFGS








