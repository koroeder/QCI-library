!   Copyright (C) 2010- David J. Wales
!
SUBROUTINE MAKE_CONPOT(NCPFIT,MINCOORDS)
USE KEY, ONLY : INTCONSEP, NREPMAX, NREPULSIVE, CONDISTREF, REPCON, INTCONSTRAINTREP, &
  & REPCUT, NCONSTRAINT, CONI, CONJ, CONDISTREFLOCAL, INTCONMAX, CONACTIVE, &
  & INTCONSTRAINREPCUT, INTREPSEP, REPI, REPJ, INTCONSTRAINTTOL, REPCUT, NREPI, NREPJ, NREPCUT, &
  & NCONGEOM, CONGEOM, NNREPULSIVE, BULKT, RIGIDBODY, TWOD, CONOFFLIST, CONOFFTRIED, &
  & INTFROZEN, FREEZE, INTFREEZET, INTFREEZETOL, INTFREEZEMIN, CONIFIX, CONJFIX, CONDISTREFFIX, REPIFIX, REPJFIX, &
  & REPCUTFIX, NCONGEOM, NREPULSIVEFIX, CONDATT, NCONSTRAINTFIX, CONCUTLOCAL, CONCUTFIX, CONCUT
USE COMMONS, ONLY: NATOMS, DEBUG, PARAM1, PARAM2, PARAM3

IMPLICIT NONE 
DOUBLE PRECISION DF, D, RMAT(3,3), DISTANCE, D2
INTEGER :: J2,ISTAT,J1,J3,J4,NCPFIT,J5,NQCIFREEZE,NDUMMY,LUNIT,GETUNIT
INTEGER NCONFORNEWATOM
DOUBLE PRECISION :: NDIST, MINCOORDS(NCPFIT,3*NATOMS), DMIN, LINTCONSTRAINTTOL, &
  &                 LXYZ(6*NATOMS), DWORST
DOUBLE PRECISION :: DMOVED(NATOMS)
LOGICAL ADDREP(NATOMS)
INTEGER NDIST1(NATOMS), NCYCLE, NUNCON1, DLIST(NATOMS)
LOGICAL :: YESNO, CALLED=.FALSE.
SAVE CALLED

WRITE(*,'(A,I6,2L5,I6)') 'make_conpot> NCONGEOM,CALLED,CONDATT,NCPFIT=',NCONGEOM,CALLED,CONDATT,NCPFIT

IF (NCONGEOM.GE.2) THEN
!
! If this is not the first call, and we are being passed two minima,
! then we are doing an interpolation metric for a new pair of minima.
! We should optimise the permutational isomers on reference minimum 1
! and then do the overall alignment with newmindist, fixing the
! permutational isomers. This should put the permutational isomers
! in register with the constraints, which were calculated for all
! the reference minima after aligning with the first.
!
   IF ((CALLED.OR.CONDATT).AND.(NCPFIT.EQ.2)) THEN
      CALL MINPERMDIST(CONGEOM(1,1:3*NATOMS),MINCOORDS(1,1:3*NATOMS),NATOMS,DEBUG, &
  &                    PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,D2,RIGIDBODY,RMAT)
      CALL MINPERMDIST(CONGEOM(1,1:3*NATOMS),MINCOORDS(2,1:3*NATOMS),NATOMS,DEBUG, &
  &                    PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,D2,RIGIDBODY,RMAT)
      CALL NEWMINDIST(MINCOORDS(1,1:3*NATOMS),MINCOORDS(2,1:3*NATOMS),NATOMS,DISTANCE, &
  &                   BULKT,TWOD,'AX    ',.FALSE.,RIGIDBODY,DEBUG,RMAT,DWORST)
   ENDIF
ENDIF

NQCIFREEZE=0
IF (FREEZE) THEN
   WRITE(*, '(A)') ' make_conpot> ERROR *** QCI has not been coded for frozen atoms yet'
   STOP
ENDIF
IF (ALLOCATED(INTFROZEN)) DEALLOCATE(INTFROZEN)
ALLOCATE(INTFROZEN(NATOMS))
INTFROZEN(1:NATOMS)=.FALSE.
DLIST(1:NATOMS)=-1
DMOVED(1:NATOMS)=1.0D100
IF (INTFREEZET) THEN
   IF (NCPFIT.GT.1) THEN
      DO J1=1,NATOMS
         DF=SQRT((MINCOORDS(1,3*(J1-1)+1)-MINCOORDS(2,3*(J1-1)+1))**2 &
  &             +(MINCOORDS(1,3*(J1-1)+2)-MINCOORDS(2,3*(J1-1)+2))**2 &
  &             +(MINCOORDS(1,3*(J1-1)+3)-MINCOORDS(2,3*(J1-1)+3))**2)
!        IF (J1.EQ.NATOMS) THEN
!           WRITE(*,'(A,6G20.10)') 'mincoords atom 400: ',MINCOORDS(1,1198:1200),MINCOORDS(2,1198:1200)
!           WRITE(*,'(A,I6,6G20.10)') 'J1,DF,INTFREEZETOL=',J1,DF,INTFREEZETOL
!        ENDIF

         IF (DF.LT.INTFREEZETOL) THEN
            NQCIFREEZE=NQCIFREEZE+1
            INTFROZEN(J1)=.TRUE.
            IF (DEBUG) WRITE(*, '(A,I6,A,F12.6,A,I6)') ' make_conpot> atom ',J1, &
  &                          ' moves less than threshold: distance=',DF,' total=',NQCIFREEZE
         ENDIF
         sortd: DO J2=1,J1
            IF (DF.LT.DMOVED(J2)) THEN
               DO J3=J1,J2+1,-1
                  DMOVED(J3)=DMOVED(J3-1)
                  DLIST(J3)=DLIST(J3-1)
               ENDDO
               DMOVED(J2)=DF
               DLIST(J2)=J1
               EXIT sortd
            ENDIF
         ENDDO sortd
      ENDDO
   ENDIF
   WRITE(*, '(A,I6,A,F12.6,A,I6)') ' make_conpot> Total number of atoms moving less than threshold=',NQCIFREEZE
ENDIF

IF (NATOMS-NQCIFREEZE.LT.INTFREEZEMIN) THEN
   DO J1=NATOMS,NATOMS-INTFREEZEMIN+1,-1
      INTFROZEN(DLIST(J1))=.FALSE.
   ENDDO
   NQCIFREEZE=MAX(0,NATOMS-INTFREEZEMIN)
   IF (DEBUG) WRITE(*, '(A,I6,A)') ' make_conpot> Freezing ',NQCIFREEZE,' atoms'
ENDIF

IF (.NOT.ALLOCATED(CONI)) THEN 
   ALLOCATE(CONI(INTCONMAX),CONJ(INTCONMAX),CONDISTREF(INTCONMAX),CONCUT(INTCONMAX),CONOFFLIST(INTCONMAX),CONOFFTRIED(INTCONMAX))
   CONOFFTRIED(1:INTCONMAX)=.FALSE.
   ALLOCATE(REPI(NREPMAX),REPJ(NREPMAX),NREPI(NREPMAX),NREPJ(NREPMAX),REPCUT(NREPMAX),NREPCUT(NREPMAX))
ENDIF

IF (NQCIFREEZE.EQ.NATOMS) THEN
   NREPULSIVE=0
   NNREPULSIVE=0
   NCONSTRAINT=0
   IF (DEBUG) WRITE(*,'(A,2I10,A,G20.10)') ' make_conpot> Total number of constraints and repulsions=', &
  &   NCONSTRAINT,NREPULSIVE
   
   IF (ALLOCATED(CONACTIVE)) DEALLOCATE(CONACTIVE)
   ALLOCATE(CONACTIVE(NCONSTRAINT))
   CONACTIVE(1:NCONSTRAINT)=.TRUE. 
   IF (ALLOCATED(CONDISTREFLOCAL)) DEALLOCATE(CONDISTREFLOCAL)
   ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
   IF (ALLOCATED(CONCUTLOCAL)) DEALLOCATE(CONCUTLOCAL)
   ALLOCATE(CONCUTLOCAL(NCONSTRAINT))
   RETURN
ENDIF

LXYZ(1:3*NATOMS)=MINCOORDS(1,1:3*NATOMS)
IF (NCPFIT.GT.1) LXYZ(3*NATOMS+1:6*NATOMS)=MINCOORDS(2,1:3*NATOMS)
CALL CHECKPERC(LXYZ,LINTCONSTRAINTTOL,NQCIFREEZE,NCPFIT)

! WRITE(*, '(A,I6,2(A,F15.5))') ' make_conpot> total distance constraints=',NCONSTRAINT
! REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT**6

!
! Fixed repulsions based on congeom file entries
! Just need to adjust the list based on any frozen atoms and check
! to make sure a new pair of minima don't have repulsive atoms within
! the current cutoff.
! 
IF (NCONGEOM.GE.2) THEN
   IF (CALLED.OR.CONDATT) THEN
      J2=0
      WRITE(*,'(A,I8)') 'NCPFIT=',NCPFIT
      DO J1=1,NREPULSIVEFIX
!
! If called with two minima check that REPCUTFIX doesn't exceed the separation in 
! either minimum.
!
         
         IF (NCPFIT.EQ.2) THEN
            DF=MIN(SQRT((MINCOORDS(1,3*(REPIFIX(J1)-1)+1)-MINCOORDS(1,3*(REPJFIX(J1)-1)+1))**2+ &
  &                     (MINCOORDS(1,3*(REPIFIX(J1)-1)+2)-MINCOORDS(1,3*(REPJFIX(J1)-1)+2))**2+ &
  &                     (MINCOORDS(1,3*(REPIFIX(J1)-1)+3)-MINCOORDS(1,3*(REPJFIX(J1)-1)+3))**2),&
                   SQRT((MINCOORDS(2,3*(REPIFIX(J1)-1)+1)-MINCOORDS(2,3*(REPJFIX(J1)-1)+1))**2+ &
  &                     (MINCOORDS(2,3*(REPIFIX(J1)-1)+2)-MINCOORDS(2,3*(REPJFIX(J1)-1)+2))**2+ &
  &                     (MINCOORDS(2,3*(REPIFIX(J1)-1)+3)-MINCOORDS(2,3*(REPJFIX(J1)-1)+3))**2))
!           WRITE(*,'(A,I8,2G20.10)') 'J1,DF,REPCUTFIX(J1)=',J1,DF,REPCUTFIX(J1)
            IF (DF.LT.REPCUTFIX(J1)) THEN
               WRITE(*, '(A,2I6,2(A,G15.5))') ' make_conpot> Reducing repulsive cutoff for atoms ', &
  &                       REPIFIX(J1),REPJFIX(J1),' from ',REPCUTFIX(J1),' to ',DF-1.0D-3
               REPCUTFIX(J1)=DF-1.0D-3
            ENDIF
         ENDIF
         IF (INTFROZEN(REPIFIX(J1)).AND.INTFROZEN(REPJFIX(J1))) CYCLE
         J2=J2+1
         REPI(J2)=REPIFIX(J1)
         REPJ(J2)=REPJFIX(J1)
         REPCUT(J2)=REPCUTFIX(J1)
      ENDDO
      NREPULSIVE=J2
      WRITE(*, '(A,I6,A)') ' make_conpot> After allowing for frozen atoms there are ',NREPULSIVE,' possible repulsions'
!     STOP !!! DJW
      NREPI(1:NREPULSIVE)=REPI(1:NREPULSIVE)
      NREPJ(1:NREPULSIVE)=REPJ(1:NREPULSIVE)
      NNREPULSIVE=NREPULSIVE
      NREPCUT(1:NREPULSIVE)=REPCUT(1:NREPULSIVE)
      IF (ALLOCATED(CONACTIVE)) DEALLOCATE(CONACTIVE)
      ALLOCATE(CONACTIVE(NCONSTRAINT))
      CONACTIVE(1:NCONSTRAINT)=.TRUE. 
      IF (ALLOCATED(CONDISTREFLOCAL)) DEALLOCATE(CONDISTREFLOCAL)
      ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
      CONDISTREFLOCAL(1:NCONSTRAINT)=CONDISTREF(1:NCONSTRAINT)
      IF (ALLOCATED(CONCUTLOCAL)) DEALLOCATE(CONCUTLOCAL)
      ALLOCATE(CONCUTLOCAL(NCONSTRAINT))
      CONCUTLOCAL(1:NCONSTRAINT)=CONCUT(1:NCONSTRAINT)
      RETURN 
   ELSE
      ALLOCATE(REPIFIX(NREPMAX),REPJFIX(NREPMAX),REPCUTFIX(NREPMAX))
   ENDIF
ENDIF
!
! The rest of this code is for initial setup. It isn't needed if CONDATT is true.
!
REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT
IF (ALLOCATED(CONDISTREFLOCAL)) DEALLOCATE(CONDISTREFLOCAL)
ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
CONDISTREFLOCAL(1:NCONSTRAINT)=CONDISTREF(1:NCONSTRAINT)
IF (ALLOCATED(CONCUTLOCAL)) DEALLOCATE(CONCUTLOCAL)
ALLOCATE(CONCUTLOCAL(NCONSTRAINT))
CONCUTLOCAL(1:NCONSTRAINT)=CONCUT(1:NCONSTRAINT)
NREPULSIVEFIX=0
PRINT *,'make_conpot> INTCONSTRAINTREP,NREPULSIVEFIX=',INTCONSTRAINTREP,NREPULSIVEFIX
IF (INTCONSTRAINTREP.EQ.0.0D0) GOTO 963
!
! Add repulsions to non-constrained atoms.
! Note that we do not limit the number of constraints per site in this
! routine, unlike NEB/lbfgs.f90, where the result will depend on the
! order in which the constraints are turned on. 
!
NDUMMY=1
DO J1=1,NATOMS
!
! Make a list of repelling atoms here and then use it
! CONI(j2) is always less than CONJ(j2) so we only need to
! cycle over a given range of constraints and continue from
! where we left off for the next atom j1
!
   ADDREP(1:MIN(J1+INTREPSEP,NATOMS))=.FALSE.
   IF (J1+INTREPSEP+1.LT.NATOMS) THEN
      ADDREP(J1+INTREPSEP+1:NATOMS)=.TRUE. ! no repulsion for atoms too close in sequence
   ENDIF
   IF (INTFROZEN(J1)) THEN
      DO J2=J1+INTREPSEP+1,NATOMS
         IF (INTFROZEN(J2)) ADDREP(J2)=.FALSE.
      ENDDO
   ENDIF
!
! Do we allow repulsions between constrained atoms?
! If commented below then yes.
!
   addloop: DO J2=NDUMMY,NCONSTRAINT
      IF (CONI(J2).EQ.J1) THEN
         ADDREP(CONJ(J2))=.FALSE.
      ELSE
         NDUMMY=J2 ! for next atom
         EXIT addloop
      ENDIF
   ENDDO addloop
   rep2: DO J2=J1+INTREPSEP+1,NATOMS

      IF (.NOT.ADDREP(J2)) CYCLE

      DMIN=1.0D100
      DO J3=1,NCPFIT
         DF=SQRT((MINCOORDS(J3,3*(J1-1)+1)-MINCOORDS(J3,3*(J2-1)+1))**2+ &
  &              (MINCOORDS(J3,3*(J1-1)+2)-MINCOORDS(J3,3*(J2-1)+2))**2+ &
  &              (MINCOORDS(J3,3*(J1-1)+3)-MINCOORDS(J3,3*(J2-1)+3))**2)
         IF (DF.LT.DMIN) DMIN=DF
      ENDDO
      
      NREPULSIVEFIX=NREPULSIVEFIX+1
      IF (NREPULSIVEFIX.GT.NREPMAX) CALL REPDOUBLE
      IF (NCONGEOM.GE.2) THEN
         REPIFIX(NREPULSIVEFIX)=J1
         REPJFIX(NREPULSIVEFIX)=J2
         REPCUTFIX(NREPULSIVEFIX)=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
      ENDIF
      REPI(NREPULSIVEFIX)=J1
      REPJ(NREPULSIVEFIX)=J2

!
! Use the minimum of the end point distances and INTCONSTRAINREPCUT for each contact.
!
      REPCUT(NREPULSIVEFIX)=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
      IF (DEBUG) WRITE(*, '(A,I6,A,I6,A,F15.5,A,I10)') ' make_conpot> Adding repulsion for atom ',J1, &
  &              ' with atom ',J2,' cutoff=',DMIN,' # repulsions ',NREPULSIVEFIX
!     IF ((REPIFIX(NREPULSIVEFIX).EQ.2024).OR.(REPJFIX(NREPULSIVEFIX).EQ.2024)) THEN
!        WRITE(*,'(A,I6,I6,3G20.10)') 'make_conpot> NREPULSIVEFIX,repifix,repjfix,df,dmin,REPCUTFIX=', &
! &         NREPULSIVEFIX,repifix(NREPULSIVEFIX),repjfix(NREPULSIVEFIX),df,dmin,REPCUTFIX(NREPULSIVEFIX)
!     ENDIF
   ENDDO rep2
ENDDO
963 CONTINUE
NREPULSIVE=NREPULSIVEFIX

WRITE(*, '(A,2I10,A,G20.10)') ' make_conpot> Total number of constraints and repulsions=', &
  &   NCONSTRAINT,NREPULSIVE,' for tolerance parameter ',LINTCONSTRAINTTOL

IF (ALLOCATED(CONACTIVE)) DEALLOCATE(CONACTIVE)
ALLOCATE(CONACTIVE(NCONSTRAINT))
CONACTIVE(1:NCONSTRAINT)=.TRUE. 
!
! congrad routines actually use NREPI, NREPJ, etc., so we must assign these.
!
NREPI(1:NREPULSIVE)=REPI(1:NREPULSIVE)
NREPJ(1:NREPULSIVE)=REPJ(1:NREPULSIVE)
NNREPULSIVE=NREPULSIVE
NREPCUT(1:NREPULSIVE)=REPCUT(1:NREPULSIVE)

IF (NCONGEOM.GE.1) THEN
   LUNIT=GETUNIT()
   OPEN(LUNIT,FILE='congeom.dat',STATUS='UNKNOWN')
   WRITE(LUNIT,'(I8)') NCONGEOM
   WRITE(LUNIT,'(3G20.10)') CONGEOM(1,1:3*NATOMS)
   WRITE(LUNIT,'(I8)') NCONSTRAINTFIX
   WRITE(LUNIT,'(10I8)') CONIFIX(1:NCONSTRAINTFIX)
   WRITE(LUNIT,'(10I8)') CONJFIX(1:NCONSTRAINTFIX)
   WRITE(LUNIT,'(6G20.10)') CONDISTREFFIX(1:NCONSTRAINTFIX)
   WRITE(LUNIT,'(6G20.10)') CONCUTFIX(1:NCONSTRAINTFIX)
   WRITE(LUNIT,'(I8)') NREPULSIVEFIX
   WRITE(LUNIT,'(10I8)') REPIFIX(1:NREPULSIVEFIX)
   WRITE(LUNIT,'(10I8)') REPJFIX(1:NREPULSIVEFIX)
   WRITE(LUNIT,'(6G20.10)') REPCUTFIX(1:NREPULSIVEFIX)
   CLOSE(LUNIT)
   STOP
ENDIF

CALLED=.TRUE.

RETURN
END SUBROUTINE MAKE_CONPOT






