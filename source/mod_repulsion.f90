MODULE REPULSION
   USE QCIPREC
   USE QCIKEYS
   IMPLICIT NONE
   INTEGER :: NREPCURR = 0
   INTEGER :: SEPREPULSION = 20
   INTEGER, ALLOCATABLE :: REPI(:), REPJ(:)
   INTEGER, ALLOCATABLE :: NREPI(:), NREPJ(:) 
   REAL(KIND = REAL64), ALLOCATABLE :: REPCUT(:), NREPCUT(:)
   REAL(KIND = REAL64) :: CHECKREPCUTOFF
   INTEGER :: NNREPULSIVE, NREPULSIVE
   CONTAINS
      SUBROUTINE ALLOC_REP_VARS(NSIZE)
         IMPLICIT NONE
         INTEGER, INTENT(IN) :: NSIZE 

         CALL DEALLOC_REP_VARS()
         ALLOCATE(REPI(NSIZE), REPJ(NSIZE), NREPI(NSIZE), NREPJ(NSIZE), &
                  REPCUT(NSIZE), NREPCUT(NSIZE))
      END SUBROUTINE ALLOC_REP_VARS


      SUBROUTINE DEALLOC_REP_VARS()
         IF (ALLOCATED(REPI)) DEALLOCATE(REPI)
         IF (ALLOCATED(REPJ)) DEALLOCATE(REPJ)
         IF (ALLOCATED(NREPI)) DEALLOCATE(NREPI)
         IF (ALLOCATED(NREPJ)) DEALLOCATE(NREPJ)
         IF (ALLOCATED(REPCUT)) DEALLOCATE(REPCUT)
         IF (ALLOCATED(NREPCUT)) DEALLOCATE(NREPCUT)        
      END SUBROUTINE DEALLOC_REP_VARS


      SUBROUTINE DOUBLE_ALLOC_REP()
         USE HELPER_FNCTS, ONLY: DOUBLE_INT_ARRAY, DOUBLE_REAL64_ARRAY
         IMPLICIT NONE
         ! call routines to increase array sizer (they preserve data)
         ! input is the old array size (NREPCURR) and the initialisation value for the new parts of the array
         CALL DOUBLE_INT_ARRAY(NREPCURR, REPI, -1)
         CALL DOUBLE_INT_ARRAY(NREPCURR, REPJ, -1)
         CALL DOUBLE_INT_ARRAY(NREPCURR, NREPI, -1)
         CALL DOUBLE_INT_ARRAY(NREPCURR, NREPJ, -1)
         CALL DOUBLE_REAL64_ARRAY(NREPCURR, REPCUT, -1.0D0)
         CALL DOUBLE_REAL64_ARRAY(NREPCURR, NREPCUT, -1.0D0)   
         !finally increase NREPCURR
         NREPCURR = 2*NREPCURR
      END SUBROUTINE DOUBLE_ALLOC_REP

      SUBROUTINE CHECKREP(XYZ, NSTART, NNSTART)
         USE QCIKEYS, ONLY: NATOMS, NIMAGES
         USE HELPER_FNCTS, ONLY: DISTANCE_TWOATOMS
         IMPLICIT NONE
         REAL(KIND = REAL64), INTENT(IN) :: XYZ(3*NATOMS*(NIMAGES+2))
         INTEGER, INTENT(IN) :: NSTART, NNSTART
         INTEGER :: J, K, NI, NJ
         REAL(KIND = REAL64) :: COMPARE, LDIST

         NNREPULSIVE = NNSTART

         ! loop over part of the repulsion list
         DO J = NSTART, NREPULSIVE
            COMPARE = (CHECKREPCUTOFF*REPCUT(J))**2
            NI = REPI(J)
            NJ = REPJ(J)
            ! now check for the distance between atoms in all images
            DO K=1,NIMAGES+2
               CALL DISTANCE_TWOATOMS(NATOMS, XYZ((K-1)*3*NATOMS+1:3*K*NATOMS) , NI, NJ, LDIST)
               IF (LDIST.LT.COMPARE) THEN
                  NNREPULSIVE = NNREPULSIVE + 1
                  NREPI(NNREPULSIVE) = NI
                  NREPJ(NNREPULSIVE) = NJ
                  NREPCUT(NNREPULSIVE) = REPCUT(J)
                  EXIT
               END IF
            END DO
         END DO

      END SUBROUTINE CHECKREP

END MODULE REPULSION